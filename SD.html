<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数独シミュレータ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 20px;
            background-color: #f0f0f0;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        #sudoku-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            width: 90vmin; /* 画面の高さの90%を基準に幅を設定 */
            height: 90vmin; /* 画面の高さの90%を基準に高さを設定 */
            max-width: 500px; /* 最大幅 */
            max-height: 500px; /* 最大高さ */
            border: 3px solid #000;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* 影を追加 */
            border-radius: 8px; /* 角を丸くする */
            overflow: hidden; /* 角丸で内容がはみ出さないようにする */
            margin-bottom: 20px; /* ボタンとの間にスペースを追加 */
        }

        .cell {
            border: 1px solid #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2vmin; /* 画面の高さに応じてフォントサイズを調整 */
            box-sizing: border-box;
            background-color: #fff;
        }

        /* 3x3ブロックの太いボーダー */
        .cell:nth-child(3n) {
            border-right-width: 2px;
        }
        .cell:nth-child(9n) {
            border-right-width: 1px; /* 最後の列は通常のボーダーに戻す */
        }
        /* 上の3x3ブロックの太いボーダー */
        .cell:nth-child(n+19):nth-child(-n+27), /* 3行目 */
        .cell:nth-child(n+46):nth-child(-n+54) { /* 6行目 */
            border-bottom-width: 2px;
        }
        /* 行の最初のセルで上ボーダーを調整 (1, 4, 7行目開始) */
        .cell:nth-child(9n-8):nth-child(n+19):nth-child(-n+27) { /* 3行目の開始セル */
            border-top-width: 2px;
        }
        .cell:nth-child(9n-8):nth-child(n+46):nth-child(-n+54) { /* 6行目の開始セル */
            border-top-width: 2px;
        }
        
        /* 既知の数字のスタイル (初期ヒントとユーザー入力の両方に適用) */
        .fixed {
            font-weight: bold;
            color: #333;
            background-color: #e9e9e9; /* 少し暗い背景色 */
            font-size: 5vmin; /* 数字を大きく表示 */
            cursor: pointer; /* 強調選択モードのときにカーソルを変える */
        }

        /* 未知のセルのサブグリッド */
        .sub-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
        }

        /* サブグリッド内の数字のスタイル */
        .sub-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8vmin; /* 画面の高さに応じてフォントサイズを調整 */
            border: 1px solid #ddd;
            cursor: pointer;
            user-select: none; /* テキスト選択を無効にする */
            transition: background-color 0.1s ease; /* ホバー時のトランジション */
        }

        .sub-cell:hover {
            background-color: #e0e0e0; /* ホバー時の背景色 */
        }

        /* 唯一の候補数字のスタイル (このセルの中で唯一) */
        .single-candidate {
            color: #ff0000; /* 赤色で表示 */
            font-weight: bold;
        }
        
        /* 縦、横、または中枠の中で唯一の候補数字のスタイル */
        .unique-candidate-highlight {
            color: #007bff; /* 青色で表示 */
            font-weight: bold;
        }

        /* 強調表示のスタイル */
        .highlighted {
            background-color: #ffc107; /* 黄色で強調 */
            animation: pulse-highlight 1s ease-in-out infinite alternate;
        }

        @keyframes pulse-highlight {
            from { background-color: #ffc107; }
            to { background-color: #ffe5a8; }
        }

        /* 不可能な候補数字のスタイル */
        .impossible {
            opacity: 0.2; /* 薄く表示 */
            pointer-events: none; /* クリック不可にする */
        }
        
        /* 強調選択モード時のカーソル */
        body.selection-mode #sudoku-board .fixed {
            cursor: crosshair;
        }

        .controls {
            display: flex;
            gap: 10px; /* ボタン間のスペース */
            margin-top: 10px;
            flex-wrap: wrap; /* 小さい画面でボタンを折り返す */
            justify-content: center;
        }

        .controls button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .controls button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        .controls button:active {
            transform: translateY(0);
            box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        .controls button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
    </style>
</head>
<body>
    <h1>数独シミュレータ</h1>
    <div id="sudoku-board"></div>

    <div class="controls">
        <button id="undoBtn">元に戻す</button>
        <button id="clearUnknownBtn">全て空にする</button>
        <button id="newProblemBtn">新しい問題作成</button>
        <button id="highlightBtn">数字を強調</button>
        <button id="saveBtn">盤面を保存</button>
        <button id="loadBtn">盤面を呼び出す</button>
    </div>

    <script>
        // 現在の数独盤面。ユーザーの入力によって変更されます。
        let currentBoard = [
            [5, 3, 0, 0, 7, 0, 0, 0, 0],
            [6, 0, 0, 1, 9, 5, 0, 0, 0],
            [0, 9, 8, 0, 0, 0, 0, 6, 0],
            [8, 0, 0, 0, 6, 0, 0, 0, 3],
            [4, 0, 0, 8, 0, 3, 0, 0, 1],
            [7, 0, 0, 0, 2, 0, 0, 0, 6],
            [0, 6, 0, 0, 0, 0, 2, 8, 0],
            [0, 0, 0, 4, 1, 9, 0, 0, 5],
            [0, 0, 0, 0, 8, 0, 0, 7, 9]
        ];

        // 盤面履歴を保存するスタック（アンドゥ機能用）
        const history = [];
        
        // 強調表示の状態を管理する変数
        let isHighlightingActive = false;
        let highlightedNumber = null;
        let isSelectionMode = false; // 新しい状態: 数字選択待ちモード
        const savedBoardKey = 'sudokuSavedBoard';

        // 盤面要素を取得
        const boardElement = document.getElementById('sudoku-board');
        const undoBtn = document.getElementById('undoBtn');
        const clearUnknownBtn = document.getElementById('clearUnknownBtn');
        const newProblemBtn = document.getElementById('newProblemBtn');
        const highlightBtn = document.getElementById('highlightBtn');
        const saveBtn = document.getElementById('saveBtn');
        const loadBtn = document.getElementById('loadBtn');
        const body = document.body;

        /**
         * 盤面のディープコピーを作成するヘルパー関数
         */
        function deepCopyBoard(board) {
            return JSON.parse(JSON.stringify(board));
        }

        /**
         * 指定された行に存在する数字のSetを返すヘルパー関数
         */
        function getNumbersInRow(board, row) {
            const numbers = new Set();
            for (let col = 0; col < 9; col++) {
                if (board[row][col] !== 0) {
                    numbers.add(board[row][col]);
                }
            }
            return numbers;
        }

        /**
         * 指定された列に存在する数字のSetを返すヘルパー関数
         */
        function getNumbersInCol(board, col) {
            const numbers = new Set();
            for (let row = 0; row < 9; row++) {
                if (board[row][col] !== 0) {
                    numbers.add(board[row][col]);
                }
            }
            return numbers;
        }

        /**
         * 指定された3x3ブロックに存在する数字のSetを返すヘルパー関数
         */
        function getNumbersInBlock(board, row, col) {
            const numbers = new Set();
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    if (board[startRow + r][startCol + c] !== 0) {
                        numbers.add(board[startRow + r][startCol + c]);
                    }
                }
            }
            return numbers;
        }

        /**
         * 指定されたセルに入力可能な候補数字の配列を返す関数
         */
        function getPossibleNumbers(board, row, col) {
            const possible = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
            const inRow = getNumbersInRow(board, row);
            inRow.forEach(num => possible.delete(num));
            const inCol = getNumbersInCol(board, col);
            inCol.forEach(num => possible.delete(num));
            const inBlock = getNumbersInBlock(board, row, col);
            inBlock.forEach(num => possible.delete(num));
            return Array.from(possible).sort((a, b) => a - b);
        }

        /**
         * 指定された行の中で、特定の数字が唯一の候補であるかをチェックする
         */
        function isUniqueCandidateInRow(board, row, col, num) {
            for (let c = 0; c < 9; c++) {
                if (c !== col && board[row][c] === 0) {
                    const possible = getPossibleNumbers(board, row, c);
                    if (possible.includes(num)) {
                        return false;
                    }
                }
            }
            return true;
        }

        /**
         * 指定された列の中で、特定の数字が唯一の候補であるかをチェックする
         */
        function isUniqueCandidateInCol(board, row, col, num) {
            for (let r = 0; r < 9; r++) {
                if (r !== row && board[r][col] === 0) {
                    const possible = getPossibleNumbers(board, r, col);
                    if (possible.includes(num)) {
                        return false;
                    }
                }
            }
            return true;
        }

        /**
         * 指定された3x3ブロックの中で、特定の数字が唯一の候補であるかをチェックする
         */
        function isUniqueCandidateInBlock(board, row, col, num) {
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    const currentRow = startRow + r;
                    const currentCol = startCol + c;
                    if ((currentRow !== row || currentCol !== col) && board[currentRow][currentCol] === 0) {
                        const possible = getPossibleNumbers(board, currentRow, currentCol);
                        if (possible.includes(num)) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        /**
         * 数独盤面を生成または再描画する関数
         */
        function createBoard() {
            boardElement.innerHTML = ''; // 既存の内容をクリア
            
            // 強調選択モードに応じてbodyにクラスを追加/削除
            if (isSelectionMode) {
                body.classList.add('selection-mode');
            } else {
                body.classList.remove('selection-mode');
            }

            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    const valueInCurrentBoard = currentBoard[row][col];

                    if (valueInCurrentBoard !== 0) {
                        cell.textContent = valueInCurrentBoard;
                        cell.classList.add('fixed');
                        
                        // 強調表示が有効で、このセルの数字が強調対象と一致する場合
                        if (isHighlightingActive && valueInCurrentBoard === highlightedNumber) {
                            cell.classList.add('highlighted');
                        }

                        cell.addEventListener('click', () => handleUserEnteredCellClick(row, col));
                    } else {
                        const possibleNumbers = getPossibleNumbers(currentBoard, row, col);
                        const subGrid = document.createElement('div');
                        subGrid.classList.add('sub-grid');
                        for (let num = 1; num <= 9; num++) {
                            const subCell = document.createElement('div');
                            subCell.classList.add('sub-cell');
                            subCell.dataset.value = num;

                            if (possibleNumbers.includes(num)) {
                                subCell.textContent = num;
                                
                                if (possibleNumbers.length === 1) {
                                    subCell.classList.add('single-candidate');
                                } else if (isUniqueCandidateInRow(currentBoard, row, col, num) ||
                                           isUniqueCandidateInCol(currentBoard, row, col, num) ||
                                           isUniqueCandidateInBlock(currentBoard, row, col, num)) {
                                    subCell.classList.add('unique-candidate-highlight');
                                }
                            } else {
                                subCell.textContent = '';
                                subCell.classList.add('impossible');
                            }
                            subCell.addEventListener('click', (event) => {
                                event.stopPropagation();
                                handleSubCellClick(subCell, row, col);
                            });
                            subGrid.appendChild(subCell);
                        }
                        cell.appendChild(subGrid);
                    }
                    boardElement.appendChild(cell);
                }
            }
            updateControlsState();
        }

        /**
         * ユーザーが入力した数字が設定されたセルをクリックした時の処理
         */
        function handleUserEnteredCellClick(row, col) {
            // 強調選択モードではない場合のみ、数字クリアを実行
            if (!isSelectionMode) {
                history.push(deepCopyBoard(currentBoard));
                currentBoard[row][col] = 0;
                createBoard();
                console.log(`セル (${row}, ${col}) の数字がクリアされました。`);
            }
        }

        /**
         * サブセルがクリックされた時の処理
         */
        function handleSubCellClick(clickedSubCell, row, col) {
            // 強調選択モードではない場合のみ、数字入力を実行
            if (!isSelectionMode) {
                if (clickedSubCell.classList.contains('impossible')) {
                    return;
                }

                history.push(deepCopyBoard(currentBoard));

                const selectedValue = parseInt(clickedSubCell.dataset.value);
                currentBoard[row][col] = selectedValue;

                createBoard(); 
                console.log(`セル (${row}, ${col}) に ${selectedValue} が確定されました。`);
            }
        }
        
        /**
         * 盤面クリック時のイベントを処理する
         */
        function handleBoardClick(event) {
            if (isSelectionMode) {
                const clickedCell = event.target.closest('.fixed');
                if (clickedCell) {
                    const num = parseInt(clickedCell.textContent);
                    isSelectionMode = false;
                    isHighlightingActive = true;
                    highlightedNumber = num;
                    highlightBtn.textContent = '強調をキャンセル'; // ボタンテキストを更新
                    createBoard();
                }
            }
        }

        /**
         * 最後の操作を取り消す（アンドゥ）機能
         */
        function undoLastMove() {
            if (history.length > 0) {
                currentBoard = history.pop();
                createBoard();
                console.log("操作が元に戻されました。");
            } else {
                console.log("これ以上元に戻す履歴がありません。");
            }
            updateControlsState();
        }

        /**
         * 盤面上の全てのマスを空にする機能
         */
        function clearAllCellsToUnknown() {
            history.push(deepCopyBoard(currentBoard));

            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    currentBoard[row][col] = 0;
                }
            }
            
            createBoard();
            console.log("盤面上の全てのマスが空になりました。");
            updateControlsState();
        }

        /**
         * 数独盤面を埋めるためのバックトラッキングソルバー
         */
        function solveSudoku(board) {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] === 0) {
                        const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5); 
                        for (const num of numbers) {
                            if (isValidPlacement(board, r, c, num)) {
                                board[r][c] = num;
                                if (solveSudoku(board)) {
                                    return true;
                                }
                                board[r][c] = 0;
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        }

        /**
         * 指定された位置に数字を置けるかチェックするヘルパー関数
         */
        function isValidPlacement(board, row, col, num) {
            for (let c = 0; c < 9; c++) {
                if (board[row][c] === num) return false;
            }
            for (let r = 0; r < 9; r++) {
                if (board[r][col] === num) return false;
            }
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    if (board[startRow + r][startCol + c] === num) return false;
                }
            }
            return true;
        }

        /**
         * 新しい数独パズルを生成する機能
         */
        function generateNewPuzzle() {
            history.push(deepCopyBoard(currentBoard));

            let tempSolvedBoard = new Array(9).fill(0).map(() => new Array(9).fill(0));
            solveSudoku(tempSolvedBoard);

            let cellsToClear = 50;
            let newPuzzleTemplate = deepCopyBoard(tempSolvedBoard);

            while (cellsToClear > 0) {
                let r = Math.floor(Math.random() * 9);
                let c = Math.floor(Math.random() * 9);

                if (newPuzzleTemplate[r][c] !== 0) {
                    newPuzzleTemplate[r][c] = 0;
                    cellsToClear--;
                }
            }

            currentBoard = deepCopyBoard(newPuzzleTemplate);
            
            history.length = 0;
            history.push(deepCopyBoard(currentBoard));
            createBoard();
            console.log("新しい問題が作成されました。");
            updateControlsState();
        }

        /**
         * 既知の数字の強調表示をオン/オフする
         */
        function toggleHighlighting() {
            // 現在のハイライトを解除
            isHighlightingActive = false;
            highlightedNumber = null;
            
            if (isSelectionMode) {
                // 選択モードを解除
                isSelectionMode = false;
                highlightBtn.textContent = '数字を強調';
            } else {
                // 選択モードを有効にする
                isSelectionMode = true;
                highlightBtn.textContent = '強調をキャンセル';
            }
            
            createBoard(); // 盤面を再描画してハイライトを適用/解除
            updateControlsState();
        }

        /**
         * 現在の盤面をブラウザのローカルストレージに保存する
         */
        function saveBoard() {
            try {
                localStorage.setItem(savedBoardKey, JSON.stringify(currentBoard));
                alert("現在の盤面が保存されました。");
            } catch (e) {
                console.error("盤面の保存に失敗しました。", e);
                alert("盤面の保存に失敗しました。");
            }
        }

        /**
         * 保存された盤面を読み込む
         */
        function loadBoard() {
            try {
                const savedData = localStorage.getItem(savedBoardKey);
                if (savedData) {
                    const savedBoard = JSON.parse(savedData);
                    // 盤面のサイズを検証（不正なデータを避けるため）
                    if (Array.isArray(savedBoard) && savedBoard.length === 9 && savedBoard.every(row => Array.isArray(row) && row.length === 9)) {
                         // 履歴を保存して、ロードした盤面を適用
                        history.push(deepCopyBoard(currentBoard));
                        currentBoard = savedBoard;
                        createBoard();
                        alert("保存された盤面を読み込みました。");
                    } else {
                        alert("保存されたデータが無効です。");
                    }
                } else {
                    alert("保存された盤面がありません。");
                }
            } catch (e) {
                console.error("盤面の読み込みに失敗しました。", e);
                alert("盤面の読み込みに失敗しました。");
            }
        }


        /**
         * コントロールボタンの状態（有効/無効）を更新する
         */
        function updateControlsState() {
            undoBtn.disabled = history.length <= 1;
        }

        // イベントリスナーを設定
        undoBtn.addEventListener('click', undoLastMove);
        clearUnknownBtn.addEventListener('click', clearAllCellsToUnknown);
        newProblemBtn.addEventListener('click', generateNewPuzzle);
        highlightBtn.addEventListener('click', toggleHighlighting);
        saveBtn.addEventListener('click', saveBoard);
        loadBtn.addEventListener('click', loadBoard);

        // 盤面全体にクリックリスナーを一つだけ設定し、イベント委譲で処理する
        boardElement.addEventListener('click', handleBoardClick);

        // ページロード時に盤面を生成
        createBoard();
        history.push(deepCopyBoard(currentBoard));
    </script>
</body>
</html>