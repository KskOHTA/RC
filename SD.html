<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数独シミュレータ</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            padding: 20px; /* マージンではなくパディングを使用 */
            margin: 0; /* マージンをリセット */
            box-sizing: border-box; /* パディングを高さに含める */
            gap: 15px; /* 子要素間の垂直方向のスペース */
            background-color: #f0f0f0;
            min-height: 100vh; /* ビューポートの高さ全体を最低限確保 */
            overflow-y: auto; /* コンテンツがオーバーフローした場合に垂直スクロールを許可 */
        }

        h1 {
            color: #333;
            margin: 0; /* bodyのgapに任せるためマージンをリセット */
            flex-shrink: 0; /* ヘッダーは縮まないように固定 */
        }

        #sudoku-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            
            /* サイズの制約 */
            /* 盤面サイズは、最大500px、利用可能な水平スペース、利用可能な垂直スペースの最小値に設定 */
            width: min(500px, calc(100vw - 40px), calc(100vh - 305px)); /* 垂直方向のバッファを調整 */
            height: min(500px, calc(100vw - 40px), calc(100vh - 305px)); /* 高さも幅と同じ計算を適用 */
            
            max-width: 500px; /* 最大幅 */
            max-height: 500px; /* 最大高さ */
            min-width: 80px; /* 最小幅 */
            min-height: 80px; /* 最小高さ */
            
            aspect-ratio: 1 / 1; /* 常に正方形を維持 */
            box-sizing: border-box; /* パディングとボーダーを幅と高さに含める */

            border: 3px solid #000;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* 影を追加 */
            border-radius: 8px; /* 角を丸くする */
            overflow: hidden; /* 角丸で内容がはみ出さないようにする */
            margin: 0; /* bodyのgapに任せるためマージンをリセット */
            align-self: center; /* 中央揃え */
        }

        .cell {
            border: 1px solid #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            background-color: #fff;
            aspect-ratio: 1 / 1; /* セル自体も正方形を強制 */
        }

        /* 3x3ブロックの太いボーダー */
        .cell:nth-child(3n) {
            border-right-width: 2px;
        }
        .cell:nth-child(9n) {
            border-right-width: 1px; /* 最後の列は通常のボーダーに戻す */
        }
        /* 上の3x3ブロックの太いボーダー */
        .cell:nth-child(n+19):nth-child(-n+27), /* 3行目 */
        .cell:nth-child(n+46):nth-child(-n+54) { /* 6行目 */
            border-bottom-width: 2px;
        }
        /* 行の最初のセルで上ボーダーを調整 (1, 4, 7行目開始) */
        .cell:nth-child(9n-8):nth-child(n+19):nth-child(-n+27) { /* 3行目の開始セル */
            border-top-width: 2px;
        }
        .cell:nth-child(9n-8):nth-child(n+46):nth-child(-n+54) { /* 6行目の開始セル */
            border-top-width: 2px;
        }
        
        /* 既知の数字のスタイル (初期ヒントとユーザー入力の両方に適用) */
        .fixed {
            font-weight: bold;
            color: #333;
            background-color: #e9e9e9; /* 少し暗い背景色 */
            font-size: clamp(10px, 4vmin, 24px); /* フォントサイズをさらに調整 */
            cursor: pointer; /* 強調選択モードのときにカーソルを変える */
        }
        
        /* 既知の枠（初期値）のスタイル */
        .initial-fixed {
            background-color: #d4d4d4;
            color: #111;
        }

        /* 固定されたマス目でクリックが無効な場合のカーソル */
        .fixed.disabled-fixed-click {
            cursor: default;
        }

        /* 未知のセルのサブグリッド */
        .sub-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
        }

        /* サブグリッド内の数字のスタイル */
        .sub-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            /* clamp(最小値, 推奨値, 最大値) */
            font-size: clamp(4px, 1.5vmin, 8px); /* フォントサイズをさらに調整 */
            border: 1px solid #ddd;
            cursor: pointer;
            user-select: none; /* テキスト選択を無効にする */
            transition: background-color 0.1s ease; /* ホバー時のトランジション */
        }

        .sub-cell:hover {
            background-color: #e0e0e0; /* ホバー時の背景色 */
        }

        /* 唯一の候補数字のスタイル (このセルの中で唯一) */
        .single-candidate {
            color: #ff0000; /* 赤色で表示 */
            font-weight: bold;
        }
        
        /* 縦、横、または中枠の中で唯一の候補数字のスタイル */
        .unique-candidate-highlight {
            color: #007bff; /* 青色で表示 */
            font-weight: bold;
        }

        /* 強調表示のスタイル */
        .highlighted {
            background-color: #ffc107; /* 黄色で強調 */
            animation: pulse-highlight 1s ease-in-out infinite alternate;
        }

        @keyframes pulse-highlight {
            from { background-color: #ffc107; }
            to { background-color: #ffe5a8; }
        }

        /* 不可能な候補数字のスタイル */
        .impossible {
            opacity: 0.2; /* 薄く表示 */
            pointer-events: none; /* クリック不可にする */
        }
        
        /* 強調選択モード時のカーソル */
        body.selection-mode #sudoku-board .fixed {
            cursor: crosshair;
        }

        .controls {
            display: flex;
            gap: 8px; /* ボタン間のスペースを微調整 */
            flex-wrap: wrap; /* 小さい画面でボタンを折り返す */
            justify-content: center;
            margin: 0; /* bodyのgapに任せるためマージンをリセット */
            flex-shrink: 0; /* コントロールは縮まないように固定 */
        }

        .controls button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        #checkSolutionBtn {
            background-color: #28a745;
        }
        #checkSolutionBtn:hover {
            background-color: #218838;
        }

        .controls button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        .controls button:active {
            transform: translateY(0);
            box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        .controls button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* メッセージボックスのスタイル */
        #messageBox {
            padding: 15px 25px;
            border-radius: 8px;
            background-color: #f8d7da; /* エラー系 */
            color: #721c24;
            border: 1px solid #f5c6cb;
            font-size: 1.1em;
            text-align: center;
            min-width: 250px;
            max-width: 90vw;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            opacity: 0; /* 最初は非表示 */
            transition: opacity 0.5s ease-in-out;
            margin: 0; /* bodyのgapに任せるためマージンをリセット */
            flex-shrink: 0; /* メッセージボックスは縮まないように固定 */
        }
        #messageBox.success {
            background-color: #d4edda; /* 成功系 */
            color: #155724;
            border-color: #c3e6cb;
        }
        #messageBox.info {
            background-color: #cce5ff;
            color: #004085;
            border-color: #b8daff;
        }
        #messageBox.visible {
            opacity: 1; /* 表示 */
        }
        
        .option-group {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 0; /* bodyのgapに任せるためマージンをリセット */
            flex-shrink: 0; /* オプショングループは縮まないように固定 */
        }
    </style>
</head>
<body>
    <h1>数独シミュレータ</h1>
    <div id="sudoku-board"></div>

    <div class="controls">
        <button id="undoBtn">元に戻す</button>
        <button id="clearUnknownBtn">全て空にする</button>
        <button id="newProblemBtn">新しい問題作成</button>
        <button id="highlightBtn">数字を強調</button>
        <button id="saveBtn">盤面を保存</button>
        <button id="loadBtn">盤面を呼び出す</button>
        <button id="checkSolutionBtn">解の存在を判定</button>
    </div>
    
    <!-- 追加したチェックボックス -->
    <div class="option-group">
        <input type="checkbox" id="disableKnownCellsCheckbox" checked>
        <label for="disableKnownCellsCheckbox">確定済みセルをロック</label>
    </div>
    
    <div id="messageBox"></div> 
    <script>
        // 現在の数独盤面。ユーザーの入力によって変更されます。
        let currentBoard = new Array(9).fill(0).map(() => new Array(9).fill(0)); 
        
        // 最初の問題の盤面を保持（既知の枠を判別するため）
        let initialBoard = new Array(9).fill(0).map(() => new Array(9).fill(0));

        // 盤面履歴を保存するスタック（アンドゥ機能用）
        const history = [];
        
        // 強調表示の状態を管理する変数
        let isHighlightingActive = false;
        let highlightedNumber = null;
        let isSelectionMode = false; // 新しい状態: 数字選択待ちモード
        const savedBoardKey = 'sudokuSavedBoard';
        
        // 新しい変数：既知の枠のクリックを無効にするかどうか (デフォルトで有効)
        let isKnownCellsDisabled = true;

        // DOM要素を取得
        const boardElement = document.getElementById('sudoku-board');
        const undoBtn = document.getElementById('undoBtn');
        const clearUnknownBtn = document.getElementById('clearUnknownBtn');
        const newProblemBtn = document.getElementById('newProblemBtn'); 
        const highlightBtn = document.getElementById('highlightBtn');
        const saveBtn = document.getElementById('saveBtn');
        const loadBtn = document.getElementById('loadBtn');
        const checkSolutionBtn = document.getElementById('checkSolutionBtn');
        const messageBox = document.getElementById('messageBox');
        const body = document.body;
        const disableKnownCellsCheckbox = document.getElementById('disableKnownCellsCheckbox');
        const h1Element = document.querySelector('h1');
        const controlsElement = document.querySelector('.controls');
        const optionGroupElement = document.querySelector('.option-group');


        /**
         * 盤面のディープコピーを作成するヘルパー関数
         */
        function deepCopyBoard(board) {
            return JSON.parse(JSON.stringify(board));
        }

        /**
         * 指定された行に存在する数字のSetを返すヘルパー関数
         */
        function getNumbersInRow(board, row) {
            const numbers = new Set();
            for (let col = 0; col < 9; col++) {
                if (board[row][col] !== 0) {
                    numbers.add(board[row][col]);
                }
            }
            return numbers;
        }

        /**
         * 指定された列に存在する数字のSetを返すヘルパー関数
         */
        function getNumbersInCol(board, col) {
            const numbers = new Set();
            for (let row = 0; row < 9; row++) {
                if (board[row][col] !== 0) {
                    numbers.add(board[row][col]);
                }
            }
            return numbers;
        }

        /**
         * 指定された3x3ブロックに存在する数字のSetを返すヘルパー関数
         */
        function getNumbersInBlock(board, row, col) {
            const numbers = new Set();
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    if (board[startRow + r][startCol + c] !== 0) {
                        numbers.add(board[startRow + r][startCol + c]);
                    }
                }
            }
            return numbers;
        }

        /**
         * 指定されたセルに入力可能な候補数字の配列を返す関数
         */
        function getPossibleNumbers(board, row, col) {
            const possible = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
            const inRow = getNumbersInRow(board, row);
            inRow.forEach(num => possible.delete(num));
            const inCol = getNumbersInCol(board, col);
            inCol.forEach(num => possible.delete(num));
            const inBlock = getNumbersInBlock(board, row, col);
            inBlock.forEach(num => possible.delete(num));
            return Array.from(possible).sort((a, b) => a - b);
        }

        /**
         * 指定された行の中で、特定の数字が唯一の候補であるかをチェックする
         */
        function isUniqueCandidateInRow(board, row, col, num) {
            for (let c = 0; c < 9; c++) {
                if (c !== col && board[row][c] === 0) {
                    const possible = getPossibleNumbers(board, row, c);
                    if (possible.includes(num)) {
                        return false;
                    }
                }
            }
            return true;
        }

        /**
         * 指定された列の中で、特定の数字が唯一の候補であるかをチェックする
         */
        function isUniqueCandidateInCol(board, row, col, num) {
            for (let r = 0; r < 9; r++) {
                if (r !== row && board[r][col] === 0) {
                    const possible = getPossibleNumbers(board, r, col);
                    if (possible.includes(num)) {
                        return false;
                    }
                }
            }
            return true;
        }

        /**
         * 指定された3x3ブロックの中で、特定の数字が唯一の候補であるかをチェックする
         */
        function isUniqueCandidateInBlock(board, row, col, num) {
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    const currentRow = startRow + r;
                    const currentCol = startCol + c;
                    if ((currentRow !== row || currentCol !== col) && board[currentRow][currentCol] === 0) {
                        const possible = getPossibleNumbers(board, currentRow, currentCol);
                        if (possible.includes(num)) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        
        /**
         * セルが最初の問題に設定されていた既知の数字であるかを判定
         */
        function isInitialFixedCell(row, col) {
            return initialBoard[row][col] !== 0;
        }

        /**
         * 数独盤面を生成または再描画する関数
         */
        function createBoard() {
            boardElement.innerHTML = ''; // 既存の内容をクリア
            
            // 強調選択モードに応じてbodyにクラスを追加/削除
            if (isSelectionMode) {
                body.classList.add('selection-mode');
            } else {
                body.classList.remove('selection-mode');
            }

            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = row; // イベント委譲のためにデータ属性を追加
                    cell.dataset.col = col;

                    const valueInCurrentBoard = currentBoard[row][col];
                    const isInitial = isInitialFixedCell(row, col);

                    if (valueInCurrentBoard !== 0) { // セルに数字が入っている場合
                        cell.textContent = valueInCurrentBoard;
                        cell.classList.add('fixed');
                        
                        if (isInitial) {
                            cell.classList.add('initial-fixed');
                        }

                        // 強調表示が有効で、このセルの数字が強調対象と一致する場合
                        if (isHighlightingActive && valueInCurrentBoard === highlightedNumber) {
                            cell.classList.add('highlighted');
                        }

                        // カーソルとクリック無効のクラス設定
                        if (isKnownCellsDisabled) {
                            // 「確定済みセルをロック」がオンの場合、全ての確定数字はクリック不可
                            cell.classList.add('disabled-fixed-click');
                        } else {
                            // オフの場合、全ての確定数字はクリック可能になるため、このクラスは削除
                            cell.classList.remove('disabled-fixed-click');
                        }
                    } else { // 空のセル、サブグリッドを表示
                        const possibleNumbers = getPossibleNumbers(currentBoard, row, col);
                        const subGrid = document.createElement('div');
                        subGrid.classList.add('sub-grid');
                        for (let num = 1; num <= 9; num++) {
                            const subCell = document.createElement('div');
                            subCell.classList.add('sub-cell');
                            subCell.dataset.value = num;

                            if (possibleNumbers.includes(num)) {
                                subCell.textContent = num;
                                
                                if (possibleNumbers.length === 1) {
                                    subCell.classList.add('single-candidate');
                                } else if (isUniqueCandidateInRow(currentBoard, row, col, num) ||
                                           isUniqueCandidateInCol(currentBoard, row, col, num) ||
                                           isUniqueCandidateInBlock(currentBoard, row, col, num)) {
                                    subCell.classList.add('unique-candidate-highlight');
                                }
                            } else {
                                subCell.textContent = '';
                                subCell.classList.add('impossible');
                            }
                            // サブセル個別のクリックリスナーは設定せず、イベント委譲で処理する
                            subGrid.appendChild(subCell);
                        }
                        cell.appendChild(subGrid);
                    }
                    boardElement.appendChild(cell);
                }
            }
            updateControlsState();
            logElementSizes(); // サイズ情報をログに出力
        }

        /**
         * 盤面上のクリックイベントを処理する（イベント委譲）
         */
        function handleBoardClicks(event) {
            const clickedCellElement = event.target.closest('.cell');
            if (!clickedCellElement) return; // 数独盤面内のセルではない場合

            const row = parseInt(clickedCellElement.dataset.row);
            const col = parseInt(clickedCellElement.dataset.col);

            // 強調選択モードの場合の処理
            if (isSelectionMode) {
                // 強調選択モードでは、常に fixed セルのクリックを許可する（クリア目的ではないため）
                if (clickedCellElement.classList.contains('fixed')) {
                    const num = parseInt(clickedCellElement.textContent);
                    isSelectionMode = false;
                    isHighlightingActive = true;
                    highlightedNumber = num;
                    highlightBtn.textContent = `強調解除 (${num})`;
                    createBoard();
                }
                return; // 強調選択モードの処理が完了したら、他の処理は行わない
            }

            // 通常のゲームプレイ時のクリック処理
            if (currentBoard[row][col] !== 0) { // セルに数字が入っている場合 (確定済みセル)
                // 「確定済みセルをロック」が有効な場合、編集を許可しない
                if (isKnownCellsDisabled) {
                    showMessage("このマスは編集できません。", "info");
                    return; 
                } else {
                    // ロックが無効な場合、確定済みセルをクリア可能にする
                    history.push(deepCopyBoard(currentBoard));
                    currentBoard[row][col] = 0;
                    createBoard();
                    showMessage(`セル (${row}, ${col}) の数字がクリアされました。`, "success");
                }
            } else { // セルが空の場合（サブセルへのクリックを処理）
                const clickedSubCellElement = event.target.closest('.sub-cell');
                if (clickedSubCellElement) {
                    const selectedValue = parseInt(clickedSubCellElement.dataset.value);
                    
                    // 候補数字として不可能マークされている場合は何もしない
                    if (clickedSubCellElement.classList.contains('impossible')) {
                        return;
                    }

                    history.push(deepCopyBoard(currentBoard));
                    currentBoard[row][col] = selectedValue;
                    createBoard();
                    showMessage(`セル (${row}, ${col}) に ${selectedValue} が確定されました。`, "success");
                }
            }
        }

        /**
         * 最後の操作を取り消す（アンドゥ）機能
         */
        function undoLastMove() {
            if (history.length > 1) {
                currentBoard = history.pop();
                createBoard();
                showMessage("操作が元に戻されました。", "success");
            } else {
                showMessage("これ以上元に戻す履歴がありません。", "error");
            }
            updateControlsState();
        }

        /**
         * 盤面上の全てのマスを空にする機能
         * （初期の数字も含めて全て空にする）
         */
        function clearAllCellsToUnknown() {
            history.push(deepCopyBoard(currentBoard)); // 現在の盤面を履歴に保存

            // 全てのマスを0（空）にする
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    currentBoard[row][col] = 0;
                }
            }
            // initialBoardもクリアして、どのマスも初期値ではない状態にする
            initialBoard = new Array(9).fill(0).map(() => new Array(9).fill(0));
            
            createBoard();
            showMessage("盤面上の全てのマスが空になりました。", "success");
            updateControlsState();
        }

        /**
         * 数独盤面を埋めるためのバックトラッキングソルバー
         * @param {Array<Array<number>>} board - 埋める盤面（変更される）
         * @returns {boolean} 盤面が埋められたかどうか
         */
        function solveSudoku(board) {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] === 0) {
                        const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5); 
                        for (const num of numbers) {
                            if (isValidPlacement(board, r, c, num)) {
                                board[r][c] = num;
                                if (solveSudoku(board)) {
                                    return true;
                                }
                                board[r][c] = 0;
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        }
        
        /**
         * 解の数を数えるためのバックトラッキングソルバー
         * @param {Array<Array<number>>} board - 解の数を数える盤面（変更される）
         * @param {number} count - 現在見つかっている解の数
         * @returns {number} 見つかった解の総数
         */
        function countSolutions(board, count = 0) {
            if (count > 1) { // 2つ以上見つかった時点で中断
                return count;
            }

            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] === 0) {
                        for (let num = 1; num <= 9; num++) {
                            if (isValidPlacement(board, r, c, num)) {
                                board[r][c] = num;
                                count = countSolutions(board, count);
                                board[r][c] = 0;
                                if (count > 1) return count; // 2つ以上見つかったら即時終了
                            }
                        }
                        return count;
                    }
                }
            }
            return count + 1; // 盤面が埋まったら解が1つ増えた
        }


        /**
         * 指定された位置に数字を置けるかチェックするヘルパー関数
         * @param {Array<Array<number>>} board - 現在の盤面
         * @param {number} row - 行インデックス
         * @param {number} col - 列インデックス
         * @param {number} num - チェックする数字
         * @returns {boolean} 配置可能かどうか
         */
        function isValidPlacement(board, row, col, num) {
            for (let c = 0; c < 9; c++) {
                if (board[row][c] === num) return false;
            }
            for (let r = 0; r < 9; r++) {
                if (board[r][col] === num) return false;
            }
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    if (board[startRow + r][startCol + c] === num) return false;
                }
            }
            return true;
        }

        /**
         * 新しい数独パズルを生成する機能
         */
        function generateNewPuzzle() {
            // currentBoardが未定義の場合があるため、history.pushの前に初期化を確認
            if (!currentBoard) {
                currentBoard = new Array(9).fill(0).map(() => new Array(9).fill(0));
            }
            history.push(deepCopyBoard(currentBoard));

            let tempSolvedBoard = new Array(9).fill(0).map(() => new Array(9).fill(0));
            solveSudoku(tempSolvedBoard);

            let cellsToClear = 50;
            let newPuzzleTemplate = deepCopyBoard(tempSolvedBoard);

            while (cellsToClear > 0) {
                let r = Math.floor(Math.random() * 9);
                let c = Math.floor(Math.random() * 9);

                if (newPuzzleTemplate[r][c] !== 0) {
                    newPuzzleTemplate[r][c] = 0;
                    cellsToClear--;
                }
            }

            currentBoard = deepCopyBoard(newPuzzleTemplate);
            initialBoard = deepCopyBoard(newPuzzleTemplate); // initialBoardも新しい問題で更新
            
            // historyをクリアしてから新しい初期盤面をpushする
            history.length = 0;
            history.push(deepCopyBoard(currentBoard));
            createBoard();
            showMessage("新しい問題が作成されました。", "success");
            updateControlsState();
        }

        /**
         * 既知の数字の強調表示をオン/オフする
         */
        function toggleHighlighting() {
            // 現在のハイライトを解除
            isHighlightingActive = false;
            highlightedNumber = null;
            
            if (isSelectionMode) {
                // 選択モードを解除
                isSelectionMode = false;
                highlightBtn.textContent = '数字を強調';
            } else {
                // 選択モードを有効にする
                isSelectionMode = true;
                highlightBtn.textContent = '強調をキャンセル';
                showMessage("強調したい数字を盤面からタップしてください。", "info");
            }
            
            createBoard(); // 盤面を再描画してハイライトを適用/解除
            updateControlsState();
        }

        /**
         * 現在の盤面をブラウザのローカルストレージに保存する
         */
        function saveBoard() {
            try {
                // 盤面と初期盤面の両方を保存する
                const dataToSave = {
                    current: currentBoard,
                    initial: initialBoard
                };
                localStorage.setItem(savedBoardKey, JSON.stringify(dataToSave));
                showMessage("現在の盤面が保存されました。", "success");
            } catch (e) {
                console.error("盤面の保存に失敗しました。", e);
                showMessage("盤面の保存に失敗しました。", "error");
            }
        }

        /**
         * 保存された盤面を読み込む
         */
        function loadBoard() {
            try {
                const savedData = localStorage.getItem(savedBoardKey);
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    const savedCurrentBoard = parsedData.current;
                    const savedInitialBoard = parsedData.initial;

                    // 盤面のサイズを検証（不正なデータを避けるため）
                    if (Array.isArray(savedCurrentBoard) && savedCurrentBoard.length === 9 && savedCurrentBoard.every(row => Array.isArray(row) && row.length === 9)) {
                         // 履歴を保存して、ロードした盤面を適用
                        history.push(deepCopyBoard(currentBoard));
                        currentBoard = savedCurrentBoard;
                        initialBoard = savedInitialBoard; // initialBoardも読み込み
                        createBoard();
                        showMessage("保存された盤面を読み込みました。", "success");
                    } else {
                        showMessage("保存されたデータが無効です。", "error");
                    }
                } else {
                    showMessage("保存された盤面がありません。", "info");
                }
            } catch (e) {
                console.error("盤面の読み込みに失敗しました。", e);
                showMessage("盤面の読み込みに失敗しました。", "error");
            }
        }

        /**
         * 現在の盤面に解が存在するかどうかを判定する
         */
        function checkSolution() {
            // 現在の盤面のコピーを作成し、ソルバーで解の数を数える
            const boardToSolve = deepCopyBoard(currentBoard);
            const solutionCount = countSolutions(boardToSolve);
            
            if (solutionCount === 1) {
                showMessage("この盤面は解ける可能性があり、一意な解が存在するようです。", "success");
            } else if (solutionCount > 1) {
                showMessage("この盤面は解ける可能性があり、複数の解が存在するようです。", "info");
            } else {
                showMessage("この盤面は解が存在しないようです。", "error");
            }
        }

        /**
         * メッセージボックスにメッセージを表示する
         * @param {string} message - 表示するメッセージ
         * @param {string} type - 'success', 'error', 'info' のいずれか
         */
        function showMessage(message, type) {
            messageBox.textContent = message;
            messageBox.className = 'visible'; // まず表示状態にする
            messageBox.classList.remove('success', 'error', 'info'); // 既存のタイプをリセット
            messageBox.classList.add(type); // 新しいタイプを追加

            // 3秒後にメッセージを非表示にする
            setTimeout(() => {
                messageBox.classList.remove('visible');
            }, 3000);
        }

        /**
         * コントロールボタンの状態（有効/無効）を更新する
         */
        function updateControlsState() {
            undoBtn.disabled = history.length <= 1;
        }

        /**
         * 各要素のサイズ情報をコンソールに出力する関数
         * この関数はデバッグ目的で、画面のサイズ変更時に自動的に実行されます。
         */
        function logElementSizes() {
            // DOMがレンダリングされてからサイズを取得するため、少し遅延させる
            setTimeout(() => {
                console.log("--- 要素サイズ情報 ---");
                console.log("Window inner dimensions:", window.innerWidth, "x", window.innerHeight);
                
                const bodyRect = document.body.getBoundingClientRect();
                console.log("Body offset dimensions (width x height):", document.body.offsetWidth, "x", document.body.offsetHeight);
                console.log("Body bounding client rect (top, right, bottom, left, width, height):", bodyRect.top, bodyRect.right, bodyRect.bottom, bodyRect.left, bodyRect.width, bodyRect.height);

                const h1Rect = h1Element.getBoundingClientRect();
                console.log("H1 ('数独シミュレータ') dimensions:", h1Rect.width, "x", h1Rect.height, "Top:", h1Rect.top);

                const boardRect = boardElement.getBoundingClientRect();
                console.log("Sudoku Board dimensions:", boardRect.width, "x", boardRect.height, "Top:", boardRect.top);
                
                // 最初のセルの情報を追加
                const firstCell = boardElement.querySelector('.cell');
                if (firstCell) {
                    const firstCellRect = firstCell.getBoundingClientRect();
                    console.log("First Cell dimensions (approx):", firstCellRect.width, "x", firstCellRect.height);

                    // 最初のセル内にサブグリッドがある場合、その最初のサブセルの情報を追加
                    const firstSubGrid = firstCell.querySelector('.sub-grid');
                    if (firstSubGrid) {
                        const firstSubCell = firstSubGrid.querySelector('.sub-cell');
                        if (firstSubCell) {
                            const firstSubCellRect = firstSubCell.getBoundingClientRect();
                            console.log("First Sub-Cell dimensions (approx):", firstSubCellRect.width, "x", firstSubCellRect.height);
                        }
                    }
                }

                const controlsRect = controlsElement.getBoundingClientRect();
                console.log("Controls dimensions:", controlsRect.width, "x", controlsRect.height, "Top:", controlsRect.top);

                const optionGroupRect = optionGroupElement.getBoundingClientRect();
                console.log("Option Group dimensions:", optionGroupRect.width, "x", optionGroupRect.height, "Top:", optionGroupRect.top);

                const messageBoxRect = messageBox.getBoundingClientRect();
                console.log("Message Box dimensions:", messageBoxRect.width, "x", messageBoxRect.height, "Top:", messageBoxRect.top);
                console.log("--- サイズ情報ここまで ---");

            }, 100); 
        }

        // イベントリスナーを設定
        undoBtn.addEventListener('click', undoLastMove);
        clearUnknownBtn.addEventListener('click', clearAllCellsToUnknown);
        newProblemBtn.addEventListener('click', generateNewPuzzle);
        highlightBtn.addEventListener('click', toggleHighlighting);
        saveBtn.addEventListener('click', saveBoard);
        loadBtn.addEventListener('click', loadBoard);
        checkSolutionBtn.addEventListener('click', checkSolution);
        
        // 数独盤面全体に対するクリックイベントリスナーを1つだけ設定
        boardElement.addEventListener('click', handleBoardClicks);

        // 新しく追加したチェックボックスのイベントリスナー
        disableKnownCellsCheckbox.addEventListener('change', (event) => {
            isKnownCellsDisabled = event.target.checked;
            createBoard(); // 設定変更時に盤面を再描画して、クリック制御を適用
            showMessage(`確定済みセルのロックが${isKnownCellsDisabled ? '有効' : '無効'}になりました。`, "info");
        });


        // ページロード時に盤面を生成
        generateNewPuzzle();

        // ウィンドウのリサイズイベントを監視して、サイズ情報をログに出力
        window.addEventListener('resize', logElementSizes);
    </script>
</body>
</html>
