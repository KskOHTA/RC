<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数独シミュレータ</title>
    <style>
        body {
            font-family: 'Inter', Arial, sans-serif; /* フォントをInterに変更 */
            display: flex;
            justify-content: flex-start; /* 上寄せ */
            align-items: center; /* 横方向中央揃え */
            flex-direction: column;
            padding: 10px; /* 全体のパディング */
            margin: 0;
            box-sizing: border-box;
            gap: 4px; /* 子要素間の垂直方向のスペースをさらに縮小 */
            background-color: #f0f0f0;
            height: 100vh; /* ビューポートの高さ全体を使用 */
            overflow: hidden; /* スクロール禁止 */
            -webkit-user-select: none; /* iOS Safariでの選択を禁止 */
            -moz-user-select: none; /* Firefoxでの選択を禁止 */
            -ms-user-select: none; /* IE/Edgeでの選択を禁止 */
            user-select: none; /* 標準の選択を禁止 */
        }

        h1 {
            color: #333;
            margin: 0;
            flex-shrink: 0; /* ヘッダーは縮まない */
            padding-bottom: 2px; /* 下のスペースをさらに縮小 */
            font-size: clamp(24px, 5vw, 36px); /* レスポンシブなフォントサイズ */
        }

        #sudoku-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            
            aspect-ratio: 1 / 1; /* 正方形であることを保証するヒントとして残す */
            box-sizing: border-box;
            border: 3px solid #000;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); /* 影を追加 */
            border-radius: 8px; /* 角を丸くする */
            overflow: hidden; /* 角丸で内容がはみ出さないようにする */
            margin: 0;
            align-self: center; /* 中央揃え */
        }

        .cell {
            border: 1px solid #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            background-color: #fff;
            aspect-ratio: 1 / 1; /* セル自体も正方形を強制 */
            min-width: 0;
            min-height: 0;
            border-radius: 4px; /* セルの角も少し丸く */
        }

        /* 3x3ブロックの太いボーダー */
        .cell:nth-child(3n) { border-right-width: 2px; }
        .cell:nth-child(9n) { border-right-width: 1px; } /* 最後の列は通常のボーダーに戻す */
        /* 上の3x3ブロックの太いボーダー */
        .cell:nth-child(n+19):nth-child(-n+27) { border-bottom-width: 2px; } /* 3行目 */
        .cell:nth-child(n+46):nth-child(-n+54) { border-bottom-width: 2px; } /* 6行目 */
        /* 行の最初のセルで上ボーダーを調整 (4, 7行目開始) */
        .cell:nth-child(9n-8):nth-child(n+19) { border-top-width: 2px; } /* 3行目の開始セル */
        .cell:nth-child(9n-8):nth-child(n+46) { border-top-width: 2px; } /* 6行目の開始セル */
        
        /* 既知の数字のスタイル (初期ヒントとユーザー入力の両方に適用) */
        .fixed {
            font-weight: bold;
            color: #333;
            background-color: #e9e9e9;
            font-size: clamp(18px, 7vmin, 32px);
            cursor: pointer;
        }
        
        /* 既知の枠（初期値）のスタイル */
        .initial-fixed {
            background-color: #d4d4d4;
            color: #111;
        }

        /* 固定されたマス目でクリックが無効な場合のカーソル */
        .fixed.disabled-fixed-click {
            cursor: default;
        }

        /* 未知のセルのサブグリッド */
        .sub-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
        }

        /* サブグリッド内の数字のスタイル */
        .sub-cell {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(6px, 2vmin, 12px);
            border: 1px solid #eee; /* 薄いボーダー */
            cursor: pointer;
            user-select: none;
            transition: background-color 0.1s ease;
        }

        .sub-cell:hover {
            background-color: #e0e0e0;
        }

        /* 唯一の候補数字のスタイル (このセルの中で唯一) */
        .single-candidate {
            color: #ff0000;
            font-weight: bold;
        }
        
        /* 縦、横、または中枠の中で唯一の候補数字のスタイル */
        .unique-candidate-highlight {
            color: #007bff;
            font-weight: bold;
        }

        /* 強調表示のスタイル */
        .highlighted {
            background-color: #ffc107;
            animation: pulse-highlight 1s ease-in-out infinite alternate;
        }

        @keyframes pulse-highlight {
            from { background-color: #ffc107; }
            to { background-color: #ffe5a8; }
        }

        /* 不可能な候補数字のスタイル */
        .impossible {
            opacity: 0.2;
            pointer-events: none;
        }
        
        /* 強調選択モード時のカーソル */
        body.selection-mode #sudoku-board .fixed {
            cursor: crosshair;
        }

        /* メインレイアウトコンテナ */
        #main-layout-container {
            display: flex;
            flex-direction: column; /* デフォルトはポートレート (縦方向) */
            align-items: center; /* 盤面と右パネルを中央揃え */
            flex-grow: 1; /* body内で利用可能な垂直スペースを全て使う */
            width: 100%; /* 全幅を使う */
            gap: 8px; /* 盤面と右パネル間のギャップ (ポートレート時) */
        }

        /* 右パネル (ボタンとチェックボックスのコンテナ) */
        #right-panel {
            display: flex;
            flex-direction: column; /* ボタンとチェックボックスは常に縦に並ぶ */
            gap: 8px; /* コントロールとオプショングループ間のギャップ */
            flex-shrink: 0; /* このパネルは縮まない */
            justify-content: flex-start; /* パネル内で上揃え */
        }

        .controls {
            display: flex; /* Flexboxを有効化 */
            gap: 5px; /* ボタン間のスペースを縮小 */
            flex-wrap: wrap; /* ボタンが複数行に折り返すのを許可 (ポートレート時) */
            justify-content: center; /* ボタンを中央揃え */
            margin: 0;
            flex-shrink: 0;
            padding-top: 5px;
        }

        .controls button {
            padding: 8px 15px; /* パディングを縮小 */
            font-size: 14px;   /* フォントサイズを縮小 */
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #007bff;
            color: white;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        #checkSolutionBtn {
            background-color: #28a745;
        }
        #checkSolutionBtn:hover {
            background-color: #218838;
        }

        .controls button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }

        .controls button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .controls button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* メッセージボックスのスタイル */
        #messageBox {
            padding: 15px 25px;
            border-radius: 8px;
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            font-size: 1.1em;
            text-align: center;
            min-width: 250px;
            max-width: 90vw;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            
            /* 新しいスタイル: レイアウトから除外し、下部に固定 */
            position: absolute; 
            bottom: 20px; 
            left: 50%;
            transform: translateX(-50%);
            z-index: 100; /* 他の要素より手前に表示 */
        }
        #messageBox.success {
            background-color: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
        }
        #messageBox.info {
            background-color: #cce5ff;
            color: #004085;
            border-color: #b8daff;
        }
        #messageBox.visible {
            opacity: 1;
        }
        
        .option-group {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 0;
            flex-shrink: 0;
        }

        /* ランドスケープモード (横長画面) のスタイル */
        @media (orientation: landscape) {
            body {
                flex-direction: row; /* h1 と main-layout-container を横に並べる */
                justify-content: flex-start; /* 全体を水平方向左揃え */
                align-items: flex-start; /* NEW: h1 と main-layout-container を垂直方向上揃え */
                gap: 10px; /* h1 と main-layout-container の間のギャップを調整 */
                padding: 5px; /* 全体のパディングを少し削減 */
            }

            h1 {
                /* h1 は左上に配置される */
                padding: 0; /* NEW: パディングをゼロにする */
                margin: 0; /* NEW: マージンをゼロにする */
                line-height: 1em; /* NEW: 行の高さを制御し、スペースを削減 */
                font-size: clamp(20px, 3vw, 28px); /* 少し小さめのフォントサイズに調整 */
                flex-shrink: 0; /* h1 は縮まないようにする */
                white-space: nowrap; /* テキストの折り返しを防ぐ */
            }

            #main-layout-container {
                flex-direction: row; /* 盤面と右パネルを左右に並べる */
                justify-content: center; /* 水平方向中央揃え */
                align-items: flex-start; /* NEW: 盤面と右パネルを垂直方向上揃え */
                height: auto; /* NEW: 高さ100%の代わりにコンテンツの高さに合わせる */
                width: auto; /* 幅はコンテンツと利用可能なスペースによって決まる */
                flex-grow: 1; /* 残りの水平スペースを全て使う */
                gap: 15px; /* 盤面と右パネル間のギャップを拡大 */
            }

            #right-panel {
                justify-content: flex-start; /* NEW: パネル内の要素を垂直方向上揃え */
                height: auto; /* NEW: 高さ100%の代わりにコンテンツの高さに合わせる */
                padding-top: 5px; /* ボードの上端と揃えるための小さなパディング */
            }

            .controls {
                flex-wrap: wrap; /* ボタンの折り返しを許可 (2列にするため) */
                flex-direction: row; /* ボタンを横に並べる */
                justify-content: center; /* ボタンを中央揃え */
                max-width: 280px; /* NEW: 調整された最大幅 (ボタンのキャプションが収まるように) */
                gap: 8px; /* ボタン間のギャップを少し拡大 */
            }

            .controls button {
                flex: 1 1 calc(50% - 4px); /* 2列にするため、幅を50%からギャップの半分を引いた値に設定 */
                max-width: calc(50% - 4px); /* 明示的な最大幅 */
                padding: 8px 10px; /* パディングを調整してボタンのサイズを適切に保つ */
                font-size: 13px; /* フォントサイズを調整 */
            }

            .option-group {
                align-self: flex-start; /* NEW: チェックボックスを上揃え */
            }
        }
    </style>
</head>
<body>
    <h1>数独シミュレータ</h1>
    <div id="main-layout-container">
        <div id="sudoku-board"></div>

        <div id="right-panel">
            <div class="controls">
                <button id="undoBtn">元に戻す</button>
                <button id="clearUnknownBtn">全て空にする</button>
                <button id="newProblemBtn">新しい問題作成</button>
                <button id="highlightBtn">数字を強調</button>
                <button id="saveBtn">盤面を保存</button>
                <button id="loadBtn">盤面を呼び出す</button>
                <button id="checkSolutionBtn">解の存在を判定</button>
            </div>
            
            <!-- 追加したチェックボックス -->
            <div class="option-group">
                <input type="checkbox" id="disableKnownCellsCheckbox" checked>
                <label for="disableKnownCellsCheckbox">確定済みセルをロック</label>
            </div>
        </div>
    </div>
    
    <div id="messageBox"></div> 
    <script>
        // 現在の数独盤面。ユーザーの入力によって変更されます。
        let currentBoard = new Array(9).fill(0).map(() => new Array(9).fill(0)); 
        
        // 最初の問題の盤面を保持（既知の枠を判別するため）
        let initialBoard = new Array(9).fill(0).map(() => new Array(9).fill(0));

        // 盤面履歴を保存するスタック（アンドゥ機能用）
        const history = [];
        
        // 強調表示の状態を管理する変数
        let isHighlightingActive = false;
        let highlightedNumber = null;
        let isSelectionMode = false; // 新しい状態: 数字選択待ちモード
        const savedBoardKey = 'sudokuSavedBoard';
        
        // 新しい変数：既知の枠のクリックを無効にするかどうか (デフォルトで有効)
        let isKnownCellsDisabled = true;

        // タッチイベント用の変数
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndTime = 0;
        let lastTapTime = 0;
        let lastTappedCell = null;
        const doubleTapThreshold = 300; // ms
        const minSwipeDistance = 30; // pixels

        // DOM要素を取得
        const boardElement = document.getElementById('sudoku-board');
        const undoBtn = document.getElementById('undoBtn');
        const clearUnknownBtn = document.getElementById('clearUnknownBtn');
        const newProblemBtn = document.getElementById('newProblemBtn'); 
        const highlightBtn = document.getElementById('highlightBtn');
        const saveBtn = document.getElementById('saveBtn');
        const loadBtn = document.getElementById('loadBtn');
        const checkSolutionBtn = document.getElementById('checkSolutionBtn');
        const messageBox = document.getElementById('messageBox');
        const body = document.body;
        const disableKnownCellsCheckbox = document.getElementById('disableKnownCellsCheckbox');


        /**
         * 盤面のディープコピーを作成するヘルパー関数
         */
        function deepCopyBoard(board) {
            return JSON.parse(JSON.stringify(board));
        }

        /**
         * 指定された行に存在する数字のSetを返すヘルパー関数
         */
        function getNumbersInRow(board, row) {
            const numbers = new Set();
            for (let col = 0; col < 9; col++) {
                if (board[row][col] !== 0) {
                    numbers.add(board[row][col]);
                }
            }
            return numbers;
        }

        /**
         * 指定された列に存在する数字のSetを返すヘルパー関数
         */
        function getNumbersInCol(board, col) {
            const numbers = new Set();
            for (let row = 0; row < 9; row++) {
                if (board[row][col] !== 0) {
                    numbers.add(board[row][col]);
                }
            }
            return numbers;
        }

        /**
         * 指定された3x3ブロックに存在する数字のSetを返すヘルパー関数
         */
        function getNumbersInBlock(board, row, col) {
            const numbers = new Set();
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    if (board[startRow + r][startCol + c] !== 0) {
                        numbers.add(board[startRow + r][startCol + c]);
                    }
                }
            }
            return numbers;
        }

        /**
         * 指定されたセルに入力可能な候補数字の配列を返す関数
         */
        function getPossibleNumbers(board, row, col) {
            const possible = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
            const inRow = getNumbersInRow(board, row);
            inRow.forEach(num => possible.delete(num));
            const inCol = getNumbersInCol(board, col);
            inCol.forEach(num => possible.delete(num));
            const inBlock = getNumbersInBlock(board, row, col);
            inBlock.forEach(num => possible.delete(num));
            return Array.from(possible).sort((a, b) => a - b);
        }

        /**
         * 指定された行の中で、特定の数字が唯一の候補であるかをチェックする
         */
        function isUniqueCandidateInRow(board, row, col, num) {
            for (let c = 0; c < 9; c++) {
                if (c !== col && board[row][c] === 0) {
                    const possible = getPossibleNumbers(board, row, c);
                    if (possible.includes(num)) {
                        return false;
                    }
                }
            }
            return true;
        }

        /**
         * 指定された列の中で、特定の数字が唯一の候補であるかをチェックする
         */
        function isUniqueCandidateInCol(board, row, col, num) {
            for (let r = 0; r < 9; r++) {
                if (r !== row && board[r][col] === 0) {
                    const possible = getPossibleNumbers(board, r, col);
                    if (possible.includes(num)) {
                        return false;
                    }
                }
            }
            return true;
        }

        /**
         * 指定された3x3ブロックの中で、特定の数字が唯一の候補であるかをチェックする
         */
        function isUniqueCandidateInBlock(board, row, col, num) {
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    const currentRow = startRow + r;
                    const currentCol = startCol + c;
                    if ((currentRow !== row || currentCol !== col) && board[currentRow][currentCol] === 0) {
                        const possible = getPossibleNumbers(board, currentRow, currentCol);
                        if (possible.includes(num)) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        
        /**
         * セルが最初の問題に設定されていた既知の数字であるかを判定
         */
        function isInitialFixedCell(row, col) {
            return initialBoard[row][col] !== 0;
        }

        /**
         * 数独盤面を生成または再描画する関数
         */
        function createBoard() {
            boardElement.innerHTML = ''; // 既存の内容をクリア
            
            // 強調選択モードに応じてbodyにクラスを追加/削除
            if (isSelectionMode) {
                body.classList.add('selection-mode');
            } else {
                body.classList.remove('selection-mode');
            }

            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = row; // イベント委譲のためにデータ属性を追加
                    cell.dataset.col = col;

                    const valueInCurrentBoard = currentBoard[row][col];
                    const isInitial = isInitialFixedCell(row, col);

                    if (valueInCurrentBoard !== 0) { // セルに数字が入っている場合
                        cell.textContent = valueInCurrentBoard;
                        cell.classList.add('fixed');
                        
                        if (isInitial) {
                            cell.classList.add('initial-fixed');
                        }

                        // 強調表示が有効で、このセルの数字が強調対象と一致する場合
                        if (isHighlightingActive && valueInCurrentBoard === highlightedNumber) {
                            cell.classList.add('highlighted');
                        }

                        // カーソルとクリック無効のクラス設定
                        if (isKnownCellsDisabled) {
                            // 「確定済みセルをロック」がオンの場合、全ての確定数字はクリック不可
                            cell.classList.add('disabled-fixed-click');
                        } else {
                            // オフの場合、全ての確定数字はクリック可能になるため、このクラスは削除
                            cell.classList.remove('disabled-fixed-click');
                        }
                    } else { // 空のセル、サブグリッドを表示
                        const possibleNumbers = getPossibleNumbers(currentBoard, row, col);
                        const subGrid = document.createElement('div');
                        subGrid.classList.add('sub-grid');
                        for (let num = 1; num <= 9; num++) {
                            const subCell = document.createElement('div');
                            subCell.classList.add('sub-cell');
                            subCell.dataset.value = num;

                            if (possibleNumbers.includes(num)) {
                                subCell.textContent = num;
                                
                                if (possibleNumbers.length === 1) {
                                    subCell.classList.add('single-candidate');
                                } else if (isUniqueCandidateInRow(currentBoard, row, col, num) ||
                                           isUniqueCandidateInCol(currentBoard, row, col, num) ||
                                           isUniqueCandidateInBlock(currentBoard, row, col, num)) {
                                    subCell.classList.add('unique-candidate-highlight');
                                }
                            } else {
                                subCell.textContent = '';
                                subCell.classList.add('impossible');
                            }
                            subGrid.appendChild(subCell);
                        }
                        cell.appendChild(subGrid);
                    }
                    boardElement.appendChild(cell);
                }
            }
            updateControlsState();
        }

        /**
         * 盤面上のクリック/タップイベントを処理する（イベント委譲）
         */
        function handleCellInteraction(clickedCellElement, row, col, selectedValue = 0) {
            // 強調選択モードの場合の処理
            if (isSelectionMode) {
                // 強調選択モードでは、常に fixed セルのクリックを許可する（クリア目的ではないため）
                if (clickedCellElement.classList.contains('fixed')) {
                    const num = parseInt(clickedCellElement.textContent);
                    isSelectionMode = false;
                    isHighlightingActive = true;
                    highlightedNumber = num;
                    highlightBtn.textContent = `強調解除 (${num})`;
                    createBoard();
                }
                return; // 強調選択モードの処理が完了したら、他の処理は行わない
            }

            // 通常のゲームプレイ時のクリック/タップ処理
            if (currentBoard[row][col] !== 0) { // セルに数字が入っている場合 (確定済みセル)
                // 「確定済みセルをロック」が有効な場合、編集を許可しない
                if (isKnownCellsDisabled) {
                    showMessage("このマスは編集できません。", "info");
                    return; 
                } else {
                    // ロックが無効な場合、確定済みセルをクリア可能にする
                    history.push(deepCopyBoard(currentBoard));
                    currentBoard[row][col] = 0;
                    createBoard();
                    showMessage(`セル (${row}, ${col}) の数字がクリアされました。`, "success");
                }
            } else { // セルが空の場合
                if (selectedValue !== 0) { // 数字が指定されている場合 (タップ/スワイプ/ダブルタップ)
                    const possibleNumbers = getPossibleNumbers(currentBoard, row, col);
                    if (possibleNumbers.includes(selectedValue)) {
                        history.push(deepCopyBoard(currentBoard));
                        currentBoard[row][col] = selectedValue;
                        createBoard();
                        showMessage(`セル (${row}, ${col}) に ${selectedValue} が確定されました。`, "success");
                    } else {
                        showMessage(`${selectedValue} はこのセルには置けません。`, "error");
                    }
                } else { // サブセルへのクリック
                    const clickedSubCellElement = event.target.closest('.sub-cell');
                    if (clickedSubCellElement) {
                        const valueFromSubCell = parseInt(clickedSubCellElement.dataset.value);
                        // 候補数字として不可能マークされている場合は何もしない
                        if (clickedSubCellElement.classList.contains('impossible')) {
                            return;
                        }
                        history.push(deepCopyBoard(currentBoard));
                        currentBoard[row][col] = valueFromSubCell;
                        createBoard();
                        showMessage(`セル (${row}, ${col}) に ${valueFromSubCell} が確定されました。`, "success");
                    }
                }
            }
        }


        /**
         * 最後の操作を取り消す（アンドゥ）機能
         */
        function undoLastMove() {
            if (history.length > 1) {
                currentBoard = history.pop();
                createBoard();
                showMessage("操作が元に戻されました。", "success");
            } else {
                showMessage("これ以上元に戻す履歴がありません。", "error");
            }
            updateControlsState();
        }

        /**
         * 盤面上の全てのマスを空にする機能
         * （初期の数字も含めて全て空にする）
         */
        function clearAllCellsToUnknown() {
            history.push(deepCopyBoard(currentBoard)); // 現在の盤面を履歴に保存

            // 全てのマスを0（空）にする
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    currentBoard[row][col] = 0;
                }
            }
            // initialBoardもクリアして、どのマスも初期値ではない状態にする
            initialBoard = new Array(9).fill(0).map(() => new Array(9).fill(0));
            
            createBoard();
            showMessage("盤面上の全てのマスが空になりました。", "success");
            updateControlsState();
        }

        /**
         * 数独盤面を埋めるためのバックトラッキングソルバー
         * @param {Array<Array<number>>} board - 埋める盤面（変更される）
         * @returns {boolean} 盤面が埋められたかどうか
         */
        function solveSudoku(board) {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] === 0) {
                        const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5); 
                        for (const num of numbers) {
                            if (isValidPlacement(board, r, c, num)) {
                                board[r][c] = num;
                                if (solveSudoku(board)) {
                                    return true;
                                }
                                board[r][c] = 0;
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        }
        
        /**
         * 解の数を数えるためのバックトラッキングソルバー
         * @param {Array<Array<number>>} board - 解の数を数える盤面（変更される）
         * @param {number} count - 現在見つかっている解の数
         * @returns {number} 見つかった解の総数
         */
        function countSolutions(board, count = 0) {
            if (count > 1) { // 2つ以上見つかった時点で中断
                return count;
            }

            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] === 0) {
                        for (let num = 1; num <= 9; num++) {
                            if (isValidPlacement(board, r, c, num)) {
                                board[r][c] = num;
                                count = countSolutions(board, count);
                                board[r][c] = 0;
                                if (count > 1) return count; // 2つ以上見つかったら即時終了
                            }
                        }
                        return count;
                    }
                }
            }
            return count + 1; // 盤面が埋まったら解が1つ増えた
        }


        /**
         * 指定された位置に数字を置けるかチェックするヘルパー関数
         * @param {Array<Array<number>>} board - 現在の盤面
         * @param {number} row - 行インデックス
         * @param {number} col - 列インデックス
         * @param {number} num - チェックする数字
         * @returns {boolean} 配置可能かどうか
         */
        function isValidPlacement(board, row, col, num) {
            for (let c = 0; c < 9; c++) {
                if (board[row][c] === num) return false;
            }
            for (let r = 0; r < 9; r++) {
                if (board[r][col] === num) return false;
            }
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    if (board[startRow + r][startCol + c] === num) return false;
                }
            }
            return true;
        }

        /**
         * 新しい数独パズルを生成する機能
         */
        function generateNewPuzzle() {
            // currentBoardが未定義の場合があるため、history.pushの前に初期化を確認
            if (!currentBoard) {
                currentBoard = new Array(9).fill(0).map(() => new Array(9).fill(0));
            }
            history.push(deepCopyBoard(currentBoard));

            let tempSolvedBoard = new Array(9).fill(0).map(() => new Array(9).fill(0));
            solveSudoku(tempSolvedBoard);

            let cellsToClear = 50; // クリアするセルの数を調整可能
            let newPuzzleTemplate = deepCopyBoard(tempSolvedBoard);

            // パズル生成のループ。一意な解を持つパズルを保証するために、解の数をチェックする。
            // 完全に一意な解を保証するのは時間がかかるため、ここでは簡略化。
            // 通常はより複雑なアルゴリズムが必要。
            while (cellsToClear > 0) {
                let r = Math.floor(Math.random() * 9);
                let c = Math.floor(Math.random() * 9);

                if (newPuzzleTemplate[r][c] !== 0) {
                    let originalValue = newPuzzleTemplate[r][c];
                    newPuzzleTemplate[r][c] = 0; // 一時的にクリア

                    // この時点での解の数をチェック（時間がかかる場合がある）
                    const tempBoardForCheck = deepCopyBoard(newPuzzleTemplate);
                    const solutions = countSolutions(tempBoardForCheck);

                    if (solutions === 1) { // 解が一意であればクリアを確定
                        cellsToClear--;
                    } else { // 一意でなければ元に戻す
                        newPuzzleTemplate[r][c] = originalValue;
                    }
                }
            }

            currentBoard = deepCopyBoard(newPuzzleTemplate);
            initialBoard = deepCopyBoard(newPuzzleTemplate); // initialBoardも新しい問題で更新
            
            // historyをクリアしてから新しい初期盤面をpushする
            history.length = 0;
            history.push(deepCopyBoard(currentBoard));
            createBoard();
            showMessage("新しい問題が作成されました。", "success");
            updateControlsState();
        }

        /**
         * 既知の数字の強調表示をオン/オフする
         */
        function toggleHighlighting() {
            // 現在のハイライトを解除
            isHighlightingActive = false;
            highlightedNumber = null;
            
            if (isSelectionMode) {
                // 選択モードを解除
                isSelectionMode = false;
                highlightBtn.textContent = '数字を強調';
            } else {
                // 選択モードを有効にする
                isSelectionMode = true;
                highlightBtn.textContent = '強調をキャンセル';
                showMessage("強調したい数字を盤面からタップしてください。", "info");
            }
            
            createBoard(); // 盤面を再描画してハイライトを適用/解除
            updateControlsState();
        }

        /**
         * 現在の盤面をブラウザのローカルストレージに保存する
         */
        function saveBoard() {
            try {
                // 盤面と初期盤面の両方を保存する
                const dataToSave = {
                    current: currentBoard,
                    initial: initialBoard
                };
                localStorage.setItem(savedBoardKey, JSON.stringify(dataToSave));
                showMessage("現在の盤面が保存されました。", "success");
            } catch (e) {
                console.error("盤面の保存に失敗しました。", e);
                showMessage("盤面の保存に失敗しました。", "error");
            }
        }

        /**
         * 保存された盤面を読み込む
         */
        function loadBoard() {
            try {
                const savedData = localStorage.getItem(savedBoardKey);
                if (savedData) {
                    const parsedData = JSON.parse(savedData);
                    const savedCurrentBoard = parsedData.current;
                    const savedInitialBoard = parsedData.initial;

                    // 盤面のサイズを検証（不正なデータを避けるため）
                    if (Array.isArray(savedCurrentBoard) && savedCurrentBoard.length === 9 && savedCurrentBoard.every(row => Array.isArray(row) && row.length === 9)) {
                         // 履歴を保存して、ロードした盤面を適用
                        history.push(deepCopyBoard(currentBoard));
                        currentBoard = savedCurrentBoard;
                        initialBoard = savedInitialBoard; // initialBoardも読み込み
                        createBoard();
                        showMessage("保存された盤面を読み込みました。", "success");
                    } else {
                        showMessage("保存されたデータが無効です。", "error");
                    }
                } else {
                    showMessage("保存された盤面がありません。", "info");
                }
            } catch (e) {
                console.error("盤面の読み込みに失敗しました。", e);
                showMessage("盤面の読み込みに失敗しました。", "error");
            }
        }

        /**
         * 現在の盤面に解が存在するかどうかを判定する
         */
        function checkSolution() {
            // 現在の盤面のコピーを作成し、ソルバーで解の数を数える
            const boardToSolve = deepCopyBoard(currentBoard);
            const solutionCount = countSolutions(boardToSolve);
            
            if (solutionCount === 1) {
                showMessage("この盤面は解ける可能性があり、一意な解が存在するようです。", "success");
            } else if (solutionCount > 1) {
                showMessage("この盤面は解ける可能性があり、複数の解が存在するようです。", "info");
            } else {
                showMessage("この盤面は解が存在しないようです。", "error");
            }
        }

        /**
         * メッセージボックスにメッセージを表示する
         * @param {string} message - 表示するメッセージ
         * @param {string} type - 'success', 'error', 'info' のいずれか
        */
        function showMessage(message, type) {
            messageBox.textContent = message;
            messageBox.className = 'visible'; // まず表示状態にする
            messageBox.classList.remove('success', 'error', 'info'); // 既存のタイプをリセット
            messageBox.classList.add(type); // 新しいタイプを追加

            // 3秒後にメッセージを非表示にする
            setTimeout(() => {
                messageBox.classList.remove('visible');
            }, 3000);
        }

        /**
         * コントロールボタンの状態（有効/無効）を更新する
         */
        function updateControlsState() {
            undoBtn.disabled = history.length <= 1;
        }

        /**
         * ボードのサイズを動的に設定する関数
         * 各UI要素の高さを考慮し、ボードが正確な整数ピクセル値の正方形になるようにします
         */
        function setBoardSize() {
            // bodyのパディングを計算
            const computedBodyStyle = getComputedStyle(body);
            const bodyPaddingTop = parseFloat(computedBodyStyle.paddingTop);
            const bodyPaddingBottom = parseFloat(computedBodyStyle.paddingBottom);
            const bodyPaddingLeft = parseFloat(computedBodyStyle.paddingLeft);
            const bodyPaddingRight = parseFloat(computedBodyStyle.paddingRight);
            
            const h1Element = document.querySelector('h1');
            const mainLayoutContainer = document.getElementById('main-layout-container');
            const rightPanelElement = document.getElementById('right-panel');

            let calculatedBoardSize;

            if (window.innerWidth > window.innerHeight) { // ランドスケープモード
                const h1Width = h1Element.offsetWidth; // h1の幅を取得
                const rightPanelWidth = rightPanelElement.offsetWidth; // 右パネルの幅を取得
                const mainLayoutContainerGap = parseFloat(getComputedStyle(mainLayoutContainer).gap); // main-layout-container内のギャップ
                const bodyGap = parseFloat(computedBodyStyle.gap); // body内のギャップ（h1とmain-layout-containerの間）

                // 盤面が利用できる水平方向のスペースを計算
                // ウィンドウの幅 - (body左右パディング) - h1の幅 - (h1とmain-layout-container間のギャップ) - 右パネルの幅 - (ボードと右パネル間のギャップ)
                const availableWidthForBoard = window.innerWidth
                                             - bodyPaddingLeft
                                             - bodyPaddingRight
                                             - h1Width
                                             - bodyGap 
                                             - rightPanelWidth
                                             - mainLayoutContainerGap;
                
                // 盤面が利用できる垂直方向のスペースを計算 (bodyの上下パディングとh1の高さ、bodyのギャップを考慮)
                // bodyのalign-itemsがflex-startなので、h1は上部に固定され、main-layout-containerはその下の残りのスペースを占める
                const availableHeightForBoard = window.innerHeight - bodyPaddingTop - bodyPaddingBottom - h1Element.offsetHeight - bodyGap;


                // 最終的なボードサイズは、最大500px、利用可能な幅、利用可能な高さのうち最も小さい値
                calculatedBoardSize = Math.min(500, availableWidthForBoard, availableHeightForBoard);

            } else { // ポートレートモード
                const h1Height = h1Element.offsetHeight; // h1の高さ
                const rightPanelHeight = rightPanelElement.offsetHeight; // 右パネルの高さ
                const bodyGap = parseFloat(computedBodyStyle.gap); // body内のギャップ
                const mainLayoutContainerGap = parseFloat(getComputedStyle(mainLayoutContainer).gap); // main-layout-container内のギャップ

                // 固定UI要素（h1, 右パネル, bodyパディング, bodyギャップ, main-layout-containerギャップ）が消費する合計垂直スペース
                const totalFixedUIHeight = h1Height + bodyPaddingTop + bodyPaddingBottom + bodyGap + rightPanelHeight + mainLayoutContainerGap; 
                
                const availableWidthInMainLayout = window.innerWidth - bodyPaddingLeft - bodyPaddingRight;
                
                // 最終的なボードサイズは、最大500px、利用可能な幅、残りの垂直スペースのうち最も小さい値
                calculatedBoardSize = Math.min(500, availableWidthInMainLayout, window.innerHeight - totalFixedUIHeight);
            }
            
            // サブピクセルレンダリングの問題を避けるため、最終的なボードサイズを整数に切り捨て
            const finalBoardSize = Math.floor(calculatedBoardSize);

            boardElement.style.width = `${finalBoardSize}px`;
            boardElement.style.height = `${finalBoardSize}px`;

            createBoard(); // 新しいサイズで盤面を再描画
        }


        // イベントリスナーを設定
        undoBtn.addEventListener('click', undoLastMove);
        clearUnknownBtn.addEventListener('click', clearAllCellsToUnknown);
        newProblemBtn.addEventListener('click', generateNewPuzzle);
        highlightBtn.addEventListener('click', toggleHighlighting);
        saveBtn.addEventListener('click', saveBoard);
        loadBtn.addEventListener('click', loadBoard);
        checkSolutionBtn.addEventListener('click', checkSolution);
        
        // 数独盤面全体に対するタッチイベントリスナー
        boardElement.addEventListener('touchstart', handleTouchStart, { passive: false });
        boardElement.addEventListener('touchmove', handleTouchMove, { passive: false });
        boardElement.addEventListener('touchend', handleTouchEnd);
        boardElement.addEventListener('click', (event) => {
            // タッチイベントで既に処理された場合はクリックイベントを無視
            if (event.detail === 0) return; // detail === 0 は通常、プログラム的に生成されたクリックイベント
            const clickedCellElement = event.target.closest('.cell');
            if (!clickedCellElement) return;
            const row = parseInt(clickedCellElement.dataset.row);
            const col = parseInt(clickedCellElement.dataset.col);
            handleCellInteraction(clickedCellElement, row, col); // 通常のクリック処理
        });

        // 新しく追加したチェックボックスのイベントリスナー
        disableKnownCellsCheckbox.addEventListener('change', (event) => {
            isKnownCellsDisabled = event.target.checked;
            createBoard(); // 設定変更時に盤面を再描画して、クリック制御を適用
            showMessage(`確定済みセルのロックが${isKnownCellsDisabled ? '有効' : '無効'}になりました。`, "info");
        });

        /**
         * タッチ開始時の処理
         */
        function handleTouchStart(event) {
            event.preventDefault(); 
            const touch = event.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchEndTime = 0; 
            lastTappedCell = event.target.closest('.cell'); 
        }

        /**
         * タッチ移動中の処理
         */
        function handleTouchMove(event) {
            event.preventDefault();
        }

        /**
         * タッチ終了時の処理
         */
        function handleTouchEnd(event) {
            const touch = event.changedTouches[0];
            const touchEndX = touch.clientX;
            const touchEndY = touch.clientY;
            const now = Date.now();
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const deltaTime = now - lastTapTime;

            const clickedCellElement = event.target.closest('.cell');
            if (!clickedCellElement) return;

            const row = parseInt(clickedCellElement.dataset.row);
            const col = parseInt(clickedCellElement.dataset.col);

            // 強調選択モードの場合の処理
            if (isSelectionMode) {
                if (clickedCellElement.classList.contains('fixed')) {
                    const num = parseInt(clickedCellElement.textContent);
                    isSelectionMode = false;
                    isHighlightingActive = true;
                    highlightedNumber = num;
                    highlightBtn.textContent = `強調解除 (${num})`;
                    createBoard();
                }
                lastTapTime = 0; 
                return; 
            }

            // 空のセルでのみフリック/ダブルタップを処理
            if (currentBoard[row][col] === 0) {
                const possibleNumbers = getPossibleNumbers(currentBoard, row, col);

                if (distance < minSwipeDistance) { 
                    // ダブルタップ判定
                    if (lastTappedCell === clickedCellElement && deltaTime < doubleTapThreshold) {
                        if (possibleNumbers.includes(5)) {
                            handleCellInteraction(clickedCellElement, row, col, 5); 
                            showMessage(`セル (${row}, ${col}) に 5 (ダブルタップ) が確定されました。`, "success");
                        } else {
                            showMessage("5 はこのセルには置けません。", "error");
                        }
                        lastTapTime = 0; 
                        lastTappedCell = null;
                        return;
                    } else {
                        const clickedSubCellElement = event.target.closest('.sub-cell');
                        if (clickedSubCellElement) {
                            const valueFromSubCell = parseInt(clickedSubCellElement.dataset.value);
                            if (clickedSubCellElement.classList.contains('impossible')) {
                                return;
                            }
                            handleCellInteraction(clickedCellElement, row, col, valueFromSubCell);
                        } else {
                            showMessage("数字の候補をタップしてください。", "info");
                        }
                    }
                    lastTapTime = now;
                    lastTappedCell = clickedCellElement;
                } else { // スワイプの可能性
                    lastTapTime = 0; 
                    lastTappedCell = null;

                    const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI; 

                    let selectedNum = 0;
                    // 角度に基づいて数字を決定
                    if (angle >= -22.5 && angle < 22.5) { // 右
                        selectedNum = 6;
                    } else if (angle >= 22.5 && angle < 67.5) { // 右下
                        selectedNum = 9;
                    } else if (angle >= 67.5 && angle < 112.5) { // 下
                        selectedNum = 8;
                    } else if (angle >= 112.5 && angle < 157.5) { // 左下
                        selectedNum = 7;
                    } else if (angle >= 157.5 || angle < -157.5) { // 左
                        selectedNum = 4;
                    } else if (angle >= -157.5 && angle < -112.5) { // 左上
                        selectedNum = 1;
                    } else if (angle >= -112.5 && angle < -67.5) { // 上
                        selectedNum = 2;
                    } else if (angle >= -67.5 && angle < -22.5) { // 右上
                        selectedNum = 3;
                    }

                    if (selectedNum !== 0 && possibleNumbers.includes(selectedNum)) {
                        handleCellInteraction(clickedCellElement, row, col, selectedNum);
                        showMessage(`セル (${row}, ${col}) に ${selectedNum} (フリック) が確定されました。`, "success");
                    } else if (selectedNum !== 0) {
                        showMessage(`${selectedNum} はこのセルには置けません。`, "error");
                    }
                }
            } else { // 固定されたセルでのタップ
                if (!isKnownCellsDisabled && distance < minSwipeDistance) {
                    handleCellInteraction(clickedCellElement, row, col);
                } else if (isKnownCellsDisabled && distance < minSwipeDistance) {
                    showMessage("このマスは編集できません。", "info");
                }
                lastTapTime = now; 
                lastTappedCell = clickedCellElement;
            }
        }


        // 初期化処理
        window.addEventListener('load', () => {
            setBoardSize(); // 最初にボードのサイズを設定
            generateNewPuzzle(); // その後、新しい問題を作成
        });
        window.addEventListener('resize', setBoardSize); // ウィンドウのリサイズ時にボードサイズを再設定
    </script>
</body>
</html>
