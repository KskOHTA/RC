<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Rubik's Cube Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* スクロールバーを非表示にする */
            display: flex;
            flex-direction: column; /* 縦方向に要素を並べる */
            font-family: Arial, sans-serif;
            background-color: #222;
            color: #eee;
        }

        canvas {
            display: block;
            flex-grow: 1; /* 画面の残りのスペースを埋める */
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 10;
            font-size: 0.9em;
            max-width: 90%; /* モバイルでの表示幅を制限 */
        }

        #info h1 {
            margin-top: 0;
            color: #fff;
        }

        #info details {
            margin-top: 10px;
            border: none;
        }

        #info summary {
            cursor: pointer;
            outline: none;
            padding: 5px 0;
            font-weight: bold;
            color: #ccc;
        }

        #info summary:hover {
            color: #fff;
        }

        #info ul {
            list-style: none;
            padding: 0;
            margin: 10px 0 0 0;
        }

        #info li {
            margin-bottom: 5px;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            z-index: 10;
            display: flex;
            gap: 10px; /* ボタン間の隙間 */
            flex-wrap: wrap; /* ボタンが多ければ折り返す */
            justify-content: center;
        }

        #controls button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            flex: 1 1 auto; /* フレックスアイテムのサイズ調整 */
            min-width: 80px; /* 最小幅 */
        }

        #controls button:hover {
            background-color: #0056b3;
        }

        #controls button:active {
            background-color: #004085;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>Rubik's Cube Simulator</h1>
        <details>
            <summary>操作説明 (テンキー):</summary>
            <ul>
                <li><b>9-9, 3-9</b>: Right面 90度時計回転</li>
                <li><b>3-3, 9-3</b>: Right面 90度反時計回転</li>
                <li><b>7-8, 8-9, 9-6, 6-3, 3-2, 2-1, 1-4, 4-7</b>: Front面 90度時計回転</li>
                <li><b>9-8, 8-7, 7-4, 4-1, 1-2, 2-3, 3-6, 6-9</b>: Front面 90度反時計回転</li>
                <li><b>7-9</b>: Top面 90度時計回転</li>
                <li><b>9-7</b>: Top面 90度反時計回転</li>
                <li><b>7-7, 1-7</b>: Left面 90度時計回転</li>
                <li><b>1-1, 7-1</b>: Left面 90度反時計回転</li>
                <li><b>1-3</b>: Bottom面 90度時計回転</li>
                <li><b>3-1</b>: Bottom面 90度反時計回転</li>
                <li><b>5-2, 8-5</b>: キューブ全体をX軸正方向へ90度回転</li>
                <li><b>5-8, 2-5</b>: キューブ全体をX軸正方向へ-90度回転</li>
                <li><b>5-4, 6-5</b>: キューブ全体をY軸正方向へ-90度回転</li>
                <li><b>5-6, 4-5</b>: キューブ全体をY軸正方向へ90度回転</li>
                <li><b>8-6, 6-2, 2-4, 4-8</b>: キューブ全体をZ軸正方向へ-90度回転</li>
                <li><b>8-4, 4-2, 2-6, 6-8</b>: キューブ全体をZ軸正方向へ90度回転</li>
                <li><b>8-8, 2-8</b>: 中央X列 (X=0) を時計回転</li>
                <li><b>8-2, 2-2</b>: 中央X列 (X=0) を反時計回転</li>
                <li><b>6-6, 4-6</b>: 中央Y列 (Y=0) を時計回転</li>
                <li><b>4-4, 6-4</b>: 中央Y列 (Y=0) を反時計回転</li>
                <li><b>5-7</b>: 中央Z列 (Z=0) を時計回転</li>
                <li><b>5-1</b>: 中央Z列 (Z=0) を反時計回転</li>
                <li><b>5-5</b>: カメラ視点をTop, Front, RightとTop, Front, Leftで切り替え (アニメーション)</li>
                <li><b>0-1</b>: **キューブをシャッフル** (アニメーション付き)</li>
                <li><b>0-0</b>: **アンドゥ** (直前の操作を取り消す)</li>
                <li><b>0-2</b>: **キューブの状態をコンソールに出力**</li>
            </ul>
        </details>
        <p>※連続してキーを入力してください。</p>
    </div>

    <div id="controls">
        <button id="shuffleBtn">シャッフル</button>
        <button id="undoBtn">アンドゥ</button>
        <button id="cameraBtn">視点切り替え</button>
        <button id="logBtn">状態ログ</button>
    </div>

    <script src="https://unpkg.com/three@0.147.0/build/three.min.js"></script>
    <script>
        // --- シーンの初期設定 ---
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // キューブ全体を回転させるためのpivotオブジェクトを追加
        const pivot = new THREE.Object3D();
        scene.add(pivot);

        camera.position.set(100, 100, 300);
        camera.lookAt(0, 0, 0);

        // --- 光源の追加 ---
        const ambientLight = new THREE.AmbientLight(0x808080);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 0, 500);
        scene.add(directionalLight);

        // --- ルービックキューブの色の定義 ---
        const colors = {
            'white': 0xffffff, 'yellow': 0xffff00, 'red': 0xff0000,
            'orange': 0xffa500, 'blue': 0x0000ff, 'green': 0x00ff00,
            'gray': 0x333333
        };

        const colorAliases = {
            [colors.white]: 'W', [colors.yellow]: 'Y', [colors.red]: 'R',
            [colors.orange]: 'O', [colors.blue]: 'B', [colors.green]: 'G',
            [colors.gray]: ' '
        };

        const cubelets = [];
        const cubeSize = 50;
        const gap = 2;

        // --- 個々のキューブレット (ミニキューブ) の作成 ---
        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                    const materials = [
                        new THREE.MeshLambertMaterial({ color: (x === 1) ? colors.orange : colors.gray }),
                        new THREE.MeshLambertMaterial({ color: (x === -1) ? colors.red : colors.gray }),
                        new THREE.MeshLambertMaterial({ color: (y === 1) ? colors.white : colors.gray }),
                        new THREE.MeshLambertMaterial({ color: (y === -1) ? colors.yellow : colors.gray }),
                        new THREE.MeshLambertMaterial({ color: (z === 1) ? colors.blue : colors.gray }),
                        new THREE.MeshLambertMaterial({ color: (z === -1) ? colors.green : colors.gray })
                    ];
                    const cubelet = new THREE.Mesh(geometry, materials);
                    cubelet.position.set(x * (cubeSize + gap), y * (cubeSize + gap), z * (cubeSize + gap));
                    pivot.add(cubelet); // キューブレットをpivotの子として追加
                    cubelets.push(cubelet);
                }
            }
        }

        // --- キー入力処理 (既存のテンキー操作はそのまま残します) ---
        let firstKey = null;
        let lastKeyPressTime = 0;
        const KEY_TIMEOUT = 500;

        window.addEventListener('keydown', (event) => {
            const currentTime = Date.now();
            const key = event.key;

            if (key >= '0' && key <= '9') {
                if (firstKey === null || (currentTime - lastKeyPressTime > KEY_TIMEOUT)) {
                    firstKey = key;
                } else {
                    const operation = firstKey + '-' + key;
                    console.log("Operation (Keypad):", operation);

                    if (operation === '0-2') { logCubeState(); }
                    else if (operation === '0-1') { shuffleCube(); }
                    else if (operation === '0-0') { undoLastMove(); }
                    else if (operation === '5-5') { changeCameraView(); }
                    else { performRotation(operation); }
                    firstKey = null;
                }
                lastKeyPressTime = currentTime;
            } else {
                firstKey = null;
            }
        });


        // --- タッチ操作関連変数 ---
        let touchStartX = 0;
        let touchStartY = 0;
        let touchCurrentX = 0;
        let touchCurrentY = 0;
        let cubeletTouched = null; // タッチ開始時に触れたキューブレット
        let rotationAxis = new THREE.Vector3();
        let targetRotationAngle = 0;
        let currentRotationAngle = 0;
        const rotationSpeed = Math.PI / 15;
        let isRotating = false;
        let isDraggingWholeCube = false; // キューブ全体をドラッグ中か
        const swipeThreshold = 30; // スワイプと認識する最低距離（ピクセル）
        const dragRotationSpeed = 0.005; // ドラッグによるキューブ全体回転の速度

        // --- タッチイベントリスナー ---
        window.addEventListener('touchstart', (event) => {
            event.preventDefault(); // スクロールやピンチズームを防ぐ

            if (isRotating || isCameraAnimating || isShuffling || isUndoing) return;

            if (event.touches.length === 1) {
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
                touchCurrentX = touchStartX;
                touchCurrentY = touchStartY;

                // Raycasterを使って、タッチした位置にあるキューブレットを特定
                const mouse = new THREE.Vector2();
                mouse.x = (touchStartX / window.innerWidth) * 2 - 1;
                mouse.y = -(touchStartY / window.innerHeight) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(cubelets);

                if (intersects.length > 0) {
                    // タッチされたオブジェクトがキューブレットの場合
                    cubeletTouched = intersects[0].object;
                    isDraggingWholeCube = false; // キューブレットを触っているので全体ドラッグではない
                } else {
                    // キューブレット以外をタッチした場合（背景をドラッグして全体回転）
                    cubeletTouched = null;
                    isDraggingWholeCube = true;
                }
            }
            // TODO: マルチタッチでの操作 (ピンチズームなど)
        });

        window.addEventListener('touchmove', (event) => {
            event.preventDefault(); // スクロールを防ぐ

            if (isRotating || isCameraAnimating || isShuffling || isUndoing) return;

            if (event.touches.length === 1) {
                const newTouchX = event.touches[0].clientX;
                const newTouchY = event.touches[0].clientY;

                if (isDraggingWholeCube) {
                    // キューブ全体をドラッグで回転
                    const deltaX = newTouchX - touchCurrentX;
                    const deltaY = newTouchY - touchCurrentY;

                    // Y軸周りの回転 (横ドラッグ)
                    pivot.rotation.y += deltaX * dragRotationSpeed;
                    // X軸周りの回転 (縦ドラッグ) - カメラの傾きを考慮
                    // 注意: 直交投影カメラとpivot回転の組み合わせは複雑になるため、ここではシンプルに実装。
                    // ユーザーの視点によっては回転方向が直感的でない場合も。
                    pivot.rotation.x += deltaY * dragRotationSpeed;

                    touchCurrentX = newTouchX;
                    touchCurrentY = newTouchY;
                }
            }
        });

        window.addEventListener('touchend', (event) => {
            if (isRotating || isCameraAnimating || isShuffling || isUndoing) return;

            if (event.changedTouches.length === 1) {
                const touchEndX = event.changedTouches[0].clientX;
                const touchEndY = event.changedTouches[0].clientY;

                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;

                if (cubeletTouched && (Math.abs(deltaX) > swipeThreshold || Math.abs(deltaY) > swipeThreshold)) {
                    // キューブレットをスワイプした場合
                    performSwipeRotation(cubeletTouched, deltaX, deltaY);
                }
            }
            cubeletTouched = null;
            isDraggingWholeCube = false;
        });

        // スワイプによる回転を判定し、performRotationを呼び出す関数
        function performSwipeRotation(touchedCubelet, deltaX, deltaY) {
            // スワイプ方向の特定
            const isHorizontalSwipe = Math.abs(deltaX) > Math.abs(deltaY);
            let operation = null;

            // タッチされたキューブレットの論理的なグリッド座標を取得
            const worldPosition = new THREE.Vector3();
            touchedCubelet.getWorldPosition(worldPosition);
            const gridX = Math.round(worldPosition.x / (cubeSize + gap));
            const gridY = Math.round(worldPosition.y / (cubeSize + gap));
            const gridZ = Math.round(worldPosition.z / (cubeSize + gap));

            // 現在のカメラの向きも考慮に入れるとより正確だが、今回はシンプルに固定視点と仮定
            // カメラの視点から見たキューブの「手前」「右」「上」を仮定して操作を割り当てる

            if (isHorizontalSwipe) { // 横方向のスワイプ
                if (gridY === 1) { // Top面付近
                    operation = (deltaX > 0) ? '7-9' : '9-7'; // U or U'
                } else if (gridY === -1) { // Bottom面付近
                    operation = (deltaX > 0) ? '3-1' : '1-3'; // D' or D (逆方向)
                } else if (gridZ === 1) { // Front面付近
                    // Front面で横スワイプ (FrontのU or D'のような操作)
                    // この操作は単純な面回転に直接マッピングしにくいが、今回はF面操作の類似として
                    // Y軸での中央列操作として扱える可能性もある (5-7, 5-1)
                    // ここでは Front面に関連するZ軸回転にマッピング
                    // FまたはF'にマッピング (スワイプ方向と画面上の向きで調整)
                    // 仮にFront面を時計回りにするには '7-8', 反時計回りにするには '9-8'
                    // 通常、ユーザーが正面から見て横にスワイプすると、Front面が水平に動くと期待する
                    // Top層のFront面で横スワイプ: UかU'にマッピングするのが自然
                    // Middle層のFront面で横スワイプ: MかM'にマッピング (このコードにはMの直接操作はない)
                    // Bottom層のFront面で横スワイプ: DかD'にマッピング
                    // ここでは簡易的に、Front面を横スワイプしたら、Front面のキーとみなす
                    operation = (deltaX > 0) ? '7-8' : '9-8'; // F or F' (仮)
                }
                // --- 中央列の回転のアイデア（長押し+スワイプなど、より高度な実装で） ---
                // if (gridX === 0 && gridZ === 1) { // 中央キューブレット付近を水平スワイプ
                //     operation = (deltaX > 0) ? '5-7' : '5-1'; // 中央Z列回転
                // }

            } else { // 縦方向のスワイプ
                if (gridX === 1) { // Right面付近
                    operation = (deltaY < 0) ? '9-9' : '3-3'; // R or R'
                } else if (gridX === -1) { // Left面付近
                    operation = (deltaY < 0) ? '1-1' : '7-7'; // L' or L (逆方向)
                } else if (gridZ === 1) { // Front面付近
                    // Front面を縦スワイプ (RかLのような操作)
                    // 通常、ユーザーが正面から見て縦にスワイプすると、RかL面が垂直に動くと期待する
                    // ここではRight面に関連するX軸回転にマッピング (Left面に触れていればLeft面)
                    // Front面とRight面が交わるエッジキューブを縦にスワイプしたら、Right面にマッピング
                    // Front面とLeft面が交わるエッジキューブを縦にスワイプしたら、Left面にマッピング
                    // 中央列の縦回転 (M or M') もここに含められる
                    // ここでは簡易的に、Front面を縦スワイプしたら、Right面に関連するキーとみなす
                    operation = (deltaY < 0) ? '9-9' : '3-3'; // R or R' (仮)
                }
                // --- 中央列の回転のアイデア（長押し+スワイプなど） ---
                // if (gridY === 0 && gridZ === 1) { // 中央キューブレット付近を縦スワイプ
                //     operation = (deltaY > 0) ? '8-8' : '8-2'; // 中央X列回転
                // }
            }

            if (operation) {
                performRotation(operation, 'user');
            } else {
                console.log("スワイプ操作が特定できませんでした。");
            }
        }


        // --- 回転処理のためのグループと状態変数 ---
        let rotatingGroup = new THREE.Group();
        // let isRotating = false; // 上で定義済み
        // let rotationAxis = new THREE.Vector3(); // 上で定義済み
        // let targetRotationAngle = 0; // 上で定義済み
        // let currentRotationAngle = 0; // 上で定義済み
        // const rotationSpeed = Math.PI / 15; // 上で定義済み

        // --- カメラアニメーションのための変数 ---
        let targetCameraPosition = camera.position.clone();
        let targetCameraQuaternion = camera.quaternion.clone();
        let isCameraAnimating = false;
        const cameraAnimationSpeed = 0.3;
        let currentView = 'TFR';

        // --- シャッフルとアンドゥのための履歴管理 ---
        const moveHistory = [];
        let shuffleQueue = [];
        let isShuffling = false;
        let isUndoing = false;

        // --- クォータニオンスナップのための参照クォータニオンを生成 ---
        const SNAP_QUATERNIONS = [];
        const basisVectors = [
            new THREE.Vector3(1, 0, 0), // X+
            new THREE.Vector3(-1, 0, 0), // X-
            new THREE.Vector3(0, 1, 0), // Y+
            new THREE.Vector3(0, -1, 0), // Y-
            new THREE.Vector3(0, 0, 1), // Z+
            new THREE.Vector3(0, 0, -1)  // Z-
        ];

        // 24通りのキューブレットの向きを生成
        for (const upVec of basisVectors) {
            for (const frontVec of basisVectors) {
                // upとfrontが同じ方向、または逆方向の場合はスキップ (直交しないため)
                if (upVec.equals(frontVec) || upVec.equals(frontVec.clone().negate())) {
                    continue;
                }
                
                // rightベクトルを計算 (upとfrontに直交)
                const rightVec = new THREE.Vector3().crossVectors(upVec, frontVec).normalize();

                // makeBasis(xAxis, yAxis, zAxis) を使用して回転行列を作成
                // THREE.Matrix4.makeBasis(xAxis, yAxis, zAxis) expects its arguments to be orthogonal and unit length.
                // In a right-handed coordinate system: xAxis, yAxis, zAxis typically form (right, up, front)
                // So, makeBasis(rightVec, upVec, frontVec) or similar based on specific axes mapping
                const mat = new THREE.Matrix4().makeBasis(rightVec, upVec, frontVec); // (X, Y, Z) basis vectors
                
                const q = new THREE.Quaternion().setFromRotationMatrix(mat);

                // 既にリストに似たクォータニオンが存在しないかチェック (浮動小数点誤差を考慮)
                let isDuplicate = false;
                // --- 修正箇所: ここでの negate() 呼び出しを削除 ---
                for (const existingQ of SNAP_QUATERNIONS) {
                    // angleToはqと-qを同じ向きとして扱うため、negate()は不要
                    if (existingQ.angleTo(q) < 0.001) {
                        isDuplicate = true;
                        break;
                    }
                }
                // --- 修正箇所ここまで ---
                if (!isDuplicate) {
                    SNAP_QUATERNIONS.push(q);
                }
            }
        }
        console.log("Generated SNAP_QUATERNIONS count:", SNAP_QUATERNIONS.length); // 24になるはず


        function performRotation(operation, source = 'user') {
            if (isRotating || isCameraAnimating) {
                if (source === 'shuffle' || source === 'undo') {
                    return;
                } else {
                    return;
                }
            }

            // --- 修正箇所: pivotのワールド行列を最新の状態に更新 ---
            // キューブレット選択の前に、pivotの姿勢が最新であることを保証
            pivot.updateMatrixWorld(true);

            let axis = new THREE.Vector3();
            let angle = 0;
            let selectAll = false;

            // --- 追加箇所: rotatingGroupのクォータニオンを明示的にリセット ---
            rotatingGroup.quaternion.identity(); // 毎回リセットしてクリーンな状態から始める

            switch (operation) {
                // --- 面の回転 (Right, Front, Top, Left, Bottom) ---
                case '9-9': case '3-9': axis.set(1, 0, 0); angle = -Math.PI / 2; selectCubeletsByPosition(1, null, null); break;
                case '3-3': case '9-3': axis.set(1, 0, 0); angle = Math.PI / 2; selectCubeletsByPosition(1, null, null); break;
                case '7-8': case '8-9': case '9-6': case '6-3': case '3-2': case '2-1': case '1-4': case '4-7': axis.set(0, 0, 1); angle = -Math.PI / 2; selectCubeletsByPosition(null, null, 1); break;
                case '9-8': case '8-7': case '7-4': case '4-1': case '1-2': case '2-3': case '3-6': case '6-9': axis.set(0, 0, 1); angle = Math.PI / 2; selectCubeletsByPosition(null, null, 1); break;
                case '7-9': axis.set(0, 1, 0); angle = Math.PI / 2; selectCubeletsByPosition(null, 1, null); break;
                case '9-7': axis.set(0, 1, 0); angle = -Math.PI / 2; selectCubeletsByPosition(null, 1, null); break;
                case '7-7': case '1-7': axis.set(-1, 0, 0); angle = Math.PI / 2; selectCubeletsByPosition(-1, null, null); break;
                case '1-1': case '7-1': axis.set(-1, 0, 0); angle = -Math.PI / 2; selectCubeletsByPosition(-1, null, null); break;
                case '1-3': axis.set(0, -1, 0); angle = -Math.PI / 2; selectCubeletsByPosition(null, -1, null); break;
                case '3-1': axis.set(0, -1, 0); angle = Math.PI / 2; selectCubeletsByPosition(null, -1, null); break;

                // --- キューブ全体の回転 (各軸周り) ---
                case '5-2': case '8-5': axis.set(1, 0, 0); angle = Math.PI / 2; selectAll = true; break;
                case '5-8': case '2-5': axis.set(1, 0, 0); angle = -Math.PI / 2; selectAll = true; break;
                case '5-4': case '6-5': axis.set(0, 1, 0); angle = -Math.PI / 2; selectAll = true; break;
                case '5-6': case '4-5': axis.set(0, 1, 0); angle = Math.PI / 2; selectAll = true; break;
                case '8-6': case '6-2': case '2-4': case '4-8': axis.set(0, 0, 1); angle = -Math.PI / 2; selectAll = true; break;
                case '8-4': case '4-2': case '2-6': case '6-8': axis.set(0, 0, 1); angle = Math.PI / 2; selectAll = true; break;

                // --- 中央列の回転 ---
                case '8-8': case '2-8': axis.set(1, 0, 0); angle = -Math.PI / 2; selectCubeletsByPosition(0, null, null); break;
                case '8-2': case '2-2': axis.set(1, 0, 0); angle = Math.PI / 2; selectCubeletsByPosition(0, null, null); break;
                case '6-6': case '4-6': axis.set(0, 1, 0); angle = Math.PI / 2; selectCubeletsByPosition(null, 0, null); break;
                case '4-4': case '6-4': axis.set(0, 1, 0); angle = -Math.PI / 2; selectCubeletsByPosition(null, 0, null); break;
                case '5-7': axis.set(0, 0, 1); angle = -Math.PI / 2; selectCubeletsByPosition(null, null, 0); break;
                case '5-1': axis.set(0, 0, 1); angle = Math.PI / 2; selectCubeletsByPosition(null, null, 0); break;

                default: console.log("不明な操作:", operation); return;
            }

            if (source !== 'undo') {
                moveHistory.push(operation);
                console.log("履歴に追加:", operation);
            }

            if (selectAll) {
                selectCubeletsByPosition(null, null, null);
            }

            rotationAxis.copy(axis);
            targetRotationAngle = angle;
            currentRotationAngle = 0;
            isRotating = true;
        }

        function selectCubeletsByPosition(xVal, yVal, zVal) {
            // pivotから回転するキューブレットを外し、rotatingGroupに一時的に追加
            for (let i = cubelets.length - 1; i >= 0; i--) {
                const cubelet = cubelets[i];
                cubelet.updateMatrixWorld(); // ここでも念のためワールド行列を更新
                const worldPosition = new THREE.Vector3();
                cubelet.getWorldPosition(worldPosition);

                const tolerance = (cubeSize + gap) / 2;

                const inX = xVal === null || Math.abs(worldPosition.x - xVal * (cubeSize + gap)) < tolerance;
                const inY = yVal === null || Math.abs(worldPosition.y - yVal * (cubeSize + gap)) < tolerance;
                const inZ = zVal === null || Math.abs(worldPosition.z - zVal * (cubeSize + gap)) < tolerance;

                if (inX && inY && inZ) {
                    pivot.remove(cubelet); // pivotから一時的に削除
                    rotatingGroup.add(cubelet);
                }
            }
            scene.add(rotatingGroup); // rotatingGroupをシーンに追加
        }

        function updateCubeletPositions(source = 'user') {
            // pivotのワールド行列を最新の状態に更新する
            // これにより、pivotのworldPositionやworldQuaternionが正確になる
            pivot.updateMatrixWorld(true);

            for (let i = rotatingGroup.children.length - 1; i >= 0; i--) {
                const cubelet = rotatingGroup.children[i];

                // キューブレットのワールド座標とワールド回転を取得（回転前の親に対する相対的な位置）
                const worldPosition = new THREE.Vector3();
                cubelet.getWorldPosition(worldPosition);
                const worldQuaternion = new THREE.Quaternion();
                cubelet.getWorldQuaternion(worldQuaternion);

                // rotatingGroupからキューブレットを削除
                rotatingGroup.remove(cubelet);

                // キューブレットのpositionとquaternionをワールド値に設定
                // これにより、次にpivotに追加されたときに正しくローカル値に変換される基盤を作る
                cubelet.position.copy(worldPosition);
                cubelet.quaternion.copy(worldQuaternion);

                // pivotの子に戻す。この時点でThree.jsがworldPositionとworldQuaternionを
                // pivotのローカル座標系に自動的に変換してcubelet.positionとcubelet.quaternionに設定する
                pivot.add(cubelet);

                // その後、pivotのローカル座標系でのcubelet.positionとcubelet.quaternionをスナップする
                const gridUnit = (cubeSize + gap);
                cubelet.position.x = Math.round(cubelet.position.x / gridUnit) * gridUnit;
                cubelet.position.y = Math.round(cubelet.position.y / gridUnit) * gridUnit;
                cubelet.position.z = Math.round(cubelet.position.z / gridUnit) * gridUnit;

                // --- クォータニオンを最も近い正規の向きにスナップ ---
                let closestQuaternion = SNAP_QUATERNIONS[0];
                let minAngle = cubelet.quaternion.angleTo(closestQuaternion);

                for (let j = 1; j < SNAP_QUATERNIONS.length; j++) {
                    const currentRefQ = SNAP_QUATERNIONS[j];
                    const angle = cubelet.quaternion.angleTo(currentRefQ);
                    if (angle < minAngle) {
                        minAngle = angle;
                        closestQuaternion = currentRefQ;
                    }
                }
                cubelet.quaternion.copy(closestQuaternion);
                // --- 修正箇所ここまで ---
            }
            rotatingGroup.clear(); // rotatingGroupを空にする
            scene.remove(rotatingGroup); // rotatingGroupをシーンから削除

            isRotating = false;

            if (isShuffling && shuffleQueue.length > 0) {
                setTimeout(() => { performRotation(shuffleQueue.shift(), 'shuffle'); }, 100);
            } else if (isShuffling && shuffleQueue.length === 0) {
                isShuffling = false;
                console.log("シャッフル完了！");
            }

            if (isUndoing && shuffleQueue.length > 0) {
                 setTimeout(() => { performRotation(shuffleQueue.shift(), 'undo'); }, 100);
            } else if (isUndoing && shuffleQueue.length === 0) {
                isUndoing = false;
                console.log("アンドゥ完了！");
            }
        }

        const ALL_FACES = [
            '9-9', '3-3', '7-8', '9-8', '7-9', '9-7', '7-7', '1-1', '1-3', '3-1',
            '5-2', '5-8', '5-4', '5-6', '8-6', '8-4', '8-8', '8-2', '6-6', '4-4', '5-7', '5-1'
        ];

        async function shuffleCube() {
            if (isRotating || isShuffling || isUndoing) return;
            console.log("シャッフルを開始します...");
            isShuffling = true;
            shuffleQueue = [];
            const numMoves = 20;
            for (let i = 0; i < numMoves; i++) {
                const randomIndex = Math.floor(Math.random() * ALL_FACES.length);
                shuffleQueue.push(ALL_FACES[randomIndex]);
            }
            performRotation(shuffleQueue.shift(), 'shuffle');
        }

        function undoLastMove() {
            if (isRotating || isShuffling || isUndoing) return;
            if (moveHistory.length === 0) {
                console.log("アンドゥできる操作がありません。");
                return;
            }
            console.log("アンドゥを開始します...");
            isUndoing = true;
            shuffleQueue = [];
            const lastMove = moveHistory.pop();
            const reverseMove = getReverseOperation(lastMove);

            if (reverseMove) {
                shuffleQueue.push(reverseMove);
                performRotation(shuffleQueue.shift(), 'undo');
                console.log(`直前の操作 "${lastMove}" をアンドゥしました。逆操作: "${reverseMove}"`);
            } else {
                console.log(`逆操作が定義されていません: ${lastMove}`);
                isUndoing = false;
            }
        }

        function getReverseOperation(operation) {
            switch (operation) {
                // --- 面の回転 ---
                case '9-9': return '3-3';
                case '3-9': return '9-3';
                case '3-3': return '9-9';
                case '9-3': return '3-9';

                case '7-8': return '9-8';
                case '8-9': return '8-7';
                case '9-6': return '6-9';
                case '6-3': return '3-6';
                case '3-2': return '2-3';
                case '2-1': return '1-2';
                case '1-4': return '7-4';
                case '4-7': return '4-1';

                case '9-8': return '7-8';
                case '8-7': return '8-9';
                case '7-4': return '1-4';
                case '4-1': return '4-7';
                case '1-2': return '2-1';
                case '2-3': return '3-2';
                case '3-6': return '6-3';
                case '6-9': return '9-6';

                case '7-9': return '9-7';
                case '9-7': return '7-9';

                case '7-7': return '1-1';
                case '1-7': return '7-1';
                case '1-1': return '7-7';
                case '7-1': return '1-7';

                case '1-3': return '3-1';
                case '3-1': return '1-3';

                // --- キューブ全体の回転 ---
                case '5-2': return '5-8';
                case '8-5': return '2-5';
                case '5-8': return '5-2';
                case '2-5': return '8-5';

                case '5-4': return '5-6';
                case '6-5': return '4-5';
                case '5-6': return '5-4';
                case '4-5': return '6-5';

                case '8-6': return '8-4';
                case '6-2': return '2-6';
                case '2-4': return '4-2';
                case '4-8': return '6-8';

                case '8-4': return '8-6';
                case '4-2': return '2-4';
                case '2-6': return '6-2';
                case '6-8': return '4-8';


                // --- 中央列の回転 ---
                case '8-8': return '8-2';
                case '2-8': return '2-2';
                case '8-2': return '8-8';
                case '2-2': return '2-8';

                case '6-6': return '4-4';
                case '4-6': return '6-4';
                case '4-4': return '6-6';
                case '6-4': return '4-6';

                case '5-7': return '5-1';
                case '5-1': return '5-7';
                default:
                    console.warn(`Warning: Reverse operation not defined for "${operation}"`);
                    return null;
            }
        }

        // --- アニメーションループ ---
        function animate() {
            requestAnimationFrame(animate);

            if (isRotating) {
                let angleStep = rotationSpeed;
                if (Math.abs(targetRotationAngle - currentRotationAngle) < angleStep) {
                    angleStep = Math.abs(targetRotationAngle - currentRotationAngle);
                    isRotating = false;
                }
                const rotateQuaternion = new THREE.Quaternion();
                rotateQuaternion.setFromAxisAngle(rotationAxis, targetRotationAngle > currentRotationAngle ? angleStep : -angleStep);
                rotatingGroup.applyQuaternion(rotateQuaternion);
                currentRotationAngle += (targetRotationAngle > currentRotationAngle ? angleStep : -angleStep);

                if (!isRotating) {
                    const source = isShuffling ? 'shuffle' : (isUndoing ? 'undo' : 'user');
                    updateCubeletPositions(source);
                }
            }

            if (isCameraAnimating) {
                camera.position.lerp(targetCameraPosition, cameraAnimationSpeed);
                camera.quaternion.slerp(targetCameraQuaternion, cameraAnimationSpeed);

                if (camera.position.distanceTo(targetCameraPosition) < 0.1 &&
                    camera.quaternion.angleTo(targetCameraQuaternion) < 0.001) {
                    camera.position.copy(targetCameraPosition);
                    camera.quaternion.copy(targetCameraQuaternion);
                    isCameraAnimating = false;
                    console.log("カメラアニメーション完了。");
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.left = width / -2;
            camera.right = width / 2;
            camera.top = height / 2;
            camera.bottom = height / -2;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
        });

        animate();

        function changeCameraView() {
            if (isCameraAnimating || isRotating || isShuffling || isUndoing) return;

            let newPosition = new THREE.Vector3();
            let newLookAt = new THREE.Vector3(0, 0, 0);

            if (currentView === 'TFR') {
                newPosition.set(-100, 100, 300);
                console.log("カメラビューをTop-Front-Leftに変更します。");
                currentView = 'TFL';
            } else {
                newPosition.set(100, 100, 300);
                console.log("カメラビューをTop-Front-Rightに変更します。");
                currentView = 'TFR';
            }

            targetCameraPosition.copy(newPosition);
            const tempCameraForTarget = new THREE.PerspectiveCamera();
            tempCameraForTarget.position.copy(newPosition);
            tempCameraForTarget.lookAt(newLookAt);
            targetCameraQuaternion.copy(tempCameraForTarget.quaternion);

            isCameraAnimating = true;
        }

        function logCubeState() {
            console.log("\n--- Rubik's Cube State ---");

            const faceStates = {
                'Top': Array(9).fill(' '), 'Bottom': Array(9).fill(' '),
                'Front': Array(9).fill(' '), 'Back': Array(9).fill(' '),
                'Left': Array(9).fill(' '), 'Right': Array(9).fill(' ')
            };

            const worldAxes = {
                'Top': new THREE.Vector3(0, 1, 0), 'Bottom': new THREE.Vector3(0, -1, 0),
                'Front': new THREE.Vector3(0, 0, 1), 'Back': new THREE.Vector3(0, 0, -1),
                'Left': new THREE.Vector3(-1, 0, 0), 'Right': new THREE.Vector3(1, 0, 0)
            };

            const tolerance = 0.01;

            cubelets.forEach(cubelet => {
                cubelet.updateMatrixWorld();

                const worldPosition = new THREE.Vector3();
                cubelet.getWorldPosition(worldPosition);

                const currentGridX = Math.round(worldPosition.x / (cubeSize + gap));
                const currentGridY = Math.round(worldPosition.y / (cubeSize + gap));
                const currentGridZ = Math.round(worldPosition.z / (cubeSize + gap));

                const localFaceNormals = [
                    new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0),
                    new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0),
                    new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)
                ];

                localFaceNormals.forEach((localNormal, materialIndex) => {
                    const worldNormal = localNormal.clone();
                    worldNormal.applyQuaternion(cubelet.quaternion);

                    const colorCode = cubelet.material[materialIndex].color.getHex();
                    const colorAlias = colorAliases[colorCode] || '?';

                    let row, col;

                    if (currentGridY === 1 && worldNormal.dot(worldAxes.Top) > 1 - tolerance) {
                        row = 1 - currentGridZ;
                        col = currentGridX + 1;
                        faceStates.Top[row * 3 + col] = colorAlias;
                    }
                    else if (currentGridY === -1 && worldNormal.dot(worldAxes.Bottom) > 1 - tolerance) {
                        row = currentGridZ + 1;
                        col = currentGridX + 1;
                        faceStates.Bottom[row * 3 + col] = colorAlias;
                    }
                    else if (currentGridZ === 1 && worldNormal.dot(worldAxes.Front) > 1 - tolerance) {
                        row = 1 - currentGridY;
                        col = currentGridX + 1;
                        faceStates.Front[row * 3 + col] = colorAlias;
                    }
                    else if (currentGridZ === -1 && worldNormal.dot(worldAxes.Back) > 1 - tolerance) {
                        row = 1 - currentGridY;
                        col = 1 - currentGridX;
                        faceStates.Back[row * 3 + col] = colorAlias;
                    }
                    else if (currentGridX === -1 && worldNormal.dot(worldAxes.Left) > 1 - tolerance) {
                        row = 1 - currentGridY;
                        col = currentGridZ + 1;
                        faceStates.Left[row * 3 + col] = colorAlias;
                    }
                    else if (currentGridX === 1 && worldNormal.dot(worldAxes.Right) > 1 - tolerance) {
                        row = 1 - currentGridY;
                        col = 1 - currentGridZ;
                        faceStates.Right[row * 3 + col] = colorAlias;
                    }
                });
            });

            const printFace = (name, colorsArr) => {
                console.log(`--- ${name} ---`);
                console.log(`${colorsArr[0]}${colorsArr[1]}${colorsArr[2]}`);
                console.log(`${colorsArr[3]}${colorsArr[4]}${colorsArr[5]}`);
                console.log(`${colorsArr[6]}${colorsArr[7]}${colorsArr[8]}`);
            };

            // ルービックキューブの標準的な配置順で各面を出力
            printFace('Top (White)', faceStates.Top);
            printFace('Left (Red)', faceStates.Left);
            printFace('Front (Blue)', faceStates.Front);
            printFace('Right (Orange)', faceStates.Right);
            printFace('Back (Green)', faceStates.Back);
            printFace('Bottom (Yellow)', faceStates.Bottom);

            console.log("----------------------");
        }

        // --- UIボタンのイベントリスナー設定 ---
        document.getElementById('shuffleBtn').addEventListener('click', shuffleCube);
        document.getElementById('undoBtn').addEventListener('click', undoLastMove);
        document.getElementById('cameraBtn').addEventListener('click', changeCameraView);
        document.getElementById('logBtn').addEventListener('click', logCubeState);

    </script>
</body>
</html>
