<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubik's Cube Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* スクロールバーを非表示にする */
            display: flex;
            font-family: Arial, sans-serif;
            background-color: #222;
            color: #eee;
        }

        canvas {
            display: block;
            touch-action: none; /* タッチジェスチャーによるブラウザのスクロールなどを無効化 */
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            font-size: 0.5em; /* 説明文のフォントサイズを小さくする */
        }

        #info h1 {
            margin-top: 0;
            color: #fff;
        }

        #info ul {
            list-style: none;
            padding: 0;
        }

        #info li {
            margin-bottom: 5px;
            line-height: 1.2em; /* 行間を調整 */
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 10;
            display: flex;
            touch-action: manipulation; /* Add this line */
            gap: 10px; /* ボタン間の隙間 */
        }

        #controls button {
            padding: 10px 15px;
            font-size: 1em;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #controls button:hover {
            background-color: #0056b3;
        }

        #controls button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        summary h2 {
            display: inline; /* h2要素をインライン表示に設定 */
            margin: 0; /* h2のデフォルトマージンをリセット */
            padding: 0; /* h2のデフォルトパディングをリセット */
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>Rubik's Cube Simulator</h1>
        <details>
            <summary>
                <h2>操作説明</h2>
            </summary>
            <p>テンキーで操作してください:</p>
            <ul>
                <h3>面の回転</h3>
                <table>
                    <thead>
                        <tr>
                            <th>面</th>
                            <th colspan="2">操作とキー</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <strong>Right面</strong>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>時計回り</td>
                                        <td>
                                            <strong>9-9, 3-9</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>反時計回り</td>
                                        <td>
                                            <strong>3-3, 9-3</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <strong>Front面</strong>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>時計回り</td>
                                        <td>
                                            <strong>7-8, 8-9, 9-6, 6-3<br/>3-2, 2-1, 1-4, 4-7</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>反時計回り</td>
                                        <td>
                                            <strong>9-8, 8-7, 7-4, 4-1<br/>1-2, 2-3, 3-6, 6-9</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <strong>Top面</strong>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>時計回り</td>
                                        <td>
                                            <strong>9-7</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>反時計回り</td>
                                        <td>
                                            <strong>7-9</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <strong>Left面</strong>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>時計回り</td>
                                        <td>
                                            <strong>1-1, 7-1</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>反時計回り</td>
                                        <td>
                                            <strong>7-7, 1-7</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <strong>Bottom面</strong>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>時計回り</td>
                                        <td>
                                            <strong>1-3</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>反時計回り</td>
                                        <td>
                                            <strong>3-1</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                    </tbody>
                </table>


                <h3>中央列の回転</h3>
                <table>
                    <thead>
                        <tr>
                            <th>列</th>
                            <th colspan="2">方向とキー</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <strong>中央X列 (X=0)</strong>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>時計回り</td>
                                        <td>
                                            <strong>8-8, 2-8</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>反時計回り</td>
                                        <td>
                                            <strong>8-2, 2-2</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <strong>中央Y列 (Y=0)</strong>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>時計回り</td>
                                        <td>
                                            <strong>6-6, 4-6</strong>
                                        </td>
                                    </tr>
                                </table>
            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>反時計回り</td>
                                        <td>
                                            <strong>4-4, 6-4</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <strong>中央Z列 (Z=0)</strong>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>時計回り</td>
                                        <td>
                                            <strong>7-3, 1-9</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>反時計回り</td>
                                        <td>
                                            <strong>3-7, 9-1</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                    </tbody>
                </table>


                <h3>キューブ全体の回転（視点変更）</h3>
                <table>
                    <thead>
                        <tr>
                            <th>軸</th>
                            <th colspan="2">方向とキー</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>
                                <strong>X軸</strong>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>反時計回り</td>
                                        <td>
                                            <strong>5-2, 8-5</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>時計回り</td>
                                        <td>
                                            <strong>5-8, 2-5</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <strong>Y軸</strong>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>反時計回り</td>
                                    <td>
                                            <strong>5-6, 4-5</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>時計回り</td>
                                        <td>
                                            <strong>5-4, 6-5</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <strong>Z軸</strong>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>反時計回り</td>
                                        <td>
                                            <strong>8-4, 4-2, 2-6, 6-8</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                            <td class="two-column-table">
                                <table>
                                    <tr>
                                        <td>時計回り</td>
                                        <td>
                                            <strong>8-6, 6-2, 2-4, 6-8</strong>
                                        </td>
                                    </tr>
                                </table>
                            </td>
                        </tr>
                    </tbody>
                </table>

                <h3>その他の操作</h3>
                <table>
                    <thead>
                        <tr>
                            <th>操作</th>
                            <th>キー</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>カメラ視点をTop, Front, RightとTop, Front, Leftで切り替え (アニメーション)</td>
                            <td>
                                <strong>5-5</strong>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <strong>キューブをシャッフル</strong> (アニメーション付き)
                            </td>
                            <td>
                                <strong>0-1</strong>
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <strong>アンドゥ</strong> (直前の操作を取り消す)
                            </td>
                            <td>
                                <strong>0-0</strong>
                        </tr>
                        <tr>
                            <td>
                                <strong>キューブ全体を透過/不透過に切り替え</strong>
                                <br>(透過時はキューブのTop, Front, Rightの9x3面が枠線表示になり、内側の面は非表示になります)
                            </td>
                            <td>
                                <strong>0-3</strong>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </ul>
            <p>※連続してキーを入力してください。</p>
        </details>
    </div>

    <div id="controls">
        <button id="shuffleButton">シャッフル</button>
        <button id="undoButton">アンドゥ</button>
        <button id="cameraViewButton">視点切替</button>
        <button id="toggleTransparencyButton">透過</button>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.147.0/build/three.min.js"></script>
    <script>
        // --- シーンの初期設定 ---
        const scene = new THREE.Scene();
        // 透視投影カメラを使用 (FOVを30に縮小)
        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true }); // アンチエイリアスを有効に
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // レンダラーでオブジェクトのソートを有効にする（透過オブジェクトの描画順を制御）
        renderer.sortObjects = true;

        // カメラの初期位置をTop-Front-Rightのアイソメトリックビューに設定 (より遠くへ)
        camera.position.set(200, 200, 600); // 透視投影に合わせて位置を調整
        camera.lookAt(0, 0, 0); // 原点を見るように設定

        // --- 光源の追加 ---
        const ambientLight = new THREE.AmbientLight(0x808080); // シーン全体を均一に照らす環境光
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5); // 特定方向から照らす平行光源 (太陽光のようなもの)
        // 光源の位置を調整して、より正面から当たるようにする
        directionalLight.position.set(0, 0, 500); // Z座標を大きくし、X, Yを0に近づけることで正面からの光を強調
        scene.add(directionalLight);

        // --- ルービックキューブの色の定義 ---
        const colors = {
            'white': 0xffffff,
            'yellow': 0xffff00,
            'red': 0xff0000,
            'orange': 0xffa500,
            'blue': 0x0000ff,
            'green': 0x00ff00,
            'black': 0x000000 // 内側の面の色
        };

        // デバッグ表示用の色の略称
        const colorAliases = {
            [colors.white]: 'W', // White
            [colors.yellow]: 'Y', // Yellow
            [colors.red]: 'R', // Red
            [colors.orange]: 'O', // Orange
            [colors.blue]: 'B', // Blue
            [colors.green]: 'G', // Green
            [colors.black]: 'K' // Black (for inner faces)
        };

        const cubelets = []; // 全てのキューブレットを格納する配列
        const cubeSize = 50; // 各キューブレットの一辺のサイズ
        const gap = 2; // キューブレット間の隙間
        const gridUnit = (cubeSize + gap); // 論理グリッドの単位

        // 枠線の設定
        const borderThickness = 3; // 枠線の太さ
        const borderOffset = 0.5; // 枠線を面からわずかに浮かせZ-fightingを防ぐためのオフセット

        // --- 透明度/枠線制御のための変数と関数 ---
        // ★修正点: アニメーション関連の変数を、使用される関数よりも前に宣言
        let currentDisplayMode = 'opaque'; // 'opaque': 不透明, 'transparent': 透過モード
        let displayModeBeforeAnimation = 'opaque'; // アニメーション開始前の表示モードを保存する新しい変数
        let rotatingGroup = new THREE.Group(); // 回転するキューブレットを一時的にまとめるグループ
        let isRotating = false; // 現在回転中かどうか
        let rotationAxis = new THREE.Vector3(); // 回転軸
        let targetRotationAngle = 0; // 目標の回転角度
        let currentRotationAngle = 0; // 現在のアニメーション回転角度
        const rotationSpeed = Math.PI / 15; // 1フレームあたりの回転速度 (シャッフルやアンドゥのために少し速くする)
        let targetCameraPosition = camera.position.clone(); // カメラの目標位置
        let targetCameraQuaternion = camera.quaternion.clone(); // カメラの目標クォータニオン (向き)
        let isCameraAnimating = false; // 現在カメラがアニメーション中かどうか
        const cameraAnimationSpeed = 0.3; // カメラアニメーションの補間速度 (0.0: 遅い - 1.0: 速い)
        let currentView = 'TFR'; // 現在のカメラビュー ('TFR': Top-Front-Right, 'TFL': Top-Front-Left)
        const moveHistory = []; // 実行された操作の履歴
        let shuffleQueue = []; // シャッフル中に実行する操作のキュー
        let isShuffling = false; // シャッフル中かどうか
        let isUndoing = false; // アンドゥ中かどうか

        // --- 個々のキューブレット (ミニキューブ) の作成 ---
        for (let x = -1; x <= 1; x++) {
            for (let y = -1; y <= 1; y++) {
                for (let z = -1; z <= 1; z++) {
                    const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
                    const materials = [];

                    // 各面の初期色を設定（X, Y, Z座標に基づいて色を決定）
                    // side: THREE.DoubleSide を設定して、裏面も描画するようにする
                    const faceConfigs = [
                        { dir: 'x', val: 1, color: colors.orange, materialIndex: 0 }, // Right (+X)
                        { dir: 'x', val: -1, color: colors.red, materialIndex: 1 },  // Left (-X)
                        { dir: 'y', val: 1, color: colors.white, materialIndex: 2 }, // Top (+Y)
                        { dir: 'y', val: -1, color: colors.yellow, materialIndex: 3 },// Bottom (-Y)
                        { dir: 'z', val: 1, color: colors.blue, materialIndex: 4 },  // Front (+Z)
                        { dir: 'z', val: -1, color: colors.green, materialIndex: 5 } // Back (-Z)
                    ];

                    faceConfigs.forEach(face => {
                        let isOuterFace = false;
                        // キューブの中心のキューブレット (0,0,0) は常に内側の面を持つ
                        if (x === 0 && y === 0 && z === 0) {
                            isOuterFace = false; // 中央キューブは常に内側
                        } else {
                            if (face.dir === 'x' && Math.abs(x) === 1 && x === face.val) isOuterFace = true;
                            if (face.dir === 'y' && Math.abs(y) === 1 && y === face.val) isOuterFace = true;
                            if (face.dir === 'z' && Math.abs(z) === 1 && z === face.val) isOuterFace = true;
                        }

                        if (isOuterFace) {
                            // 外側の面は通常色で、両面描画
                            materials[face.materialIndex] = new THREE.MeshLambertMaterial({ color: face.color, side: THREE.DoubleSide });
                        } else {
                            // 内側の面は黒色で、両面描画
                            materials[face.materialIndex] = new THREE.MeshLambertMaterial({ color: colors.black, side: THREE.DoubleSide });
                        }
                    });

                    // BoxGeometryにマテリアル配列を渡す
                    const cubelet = new THREE.Mesh(geometry, materials);
                    // キューブレットの位置を設定（中央のキューブを原点とする）
                    cubelet.position.set(x * gridUnit, y * gridUnit, z * gridUnit);
                    scene.add(cubelet);
                    cubelets.push(cubelet);
                }
            }
        }

        const localFaceNormals = [
            new THREE.Vector3(1, 0, 0),    // 0: Right (+X)
            new THREE.Vector3(-1, 0, 0),   // 1: Left (-X)
            new THREE.Vector3(0, 1, 0),    // 2: Top (+Y)
            new THREE.Vector3(0, -1, 0),   // 3: Bottom (-Y)
            new THREE.Vector3(0, 0, 1),    // 4: Front (+Z)
            new THREE.Vector3(0, 0, -1)    // 5: Back (-Z)
        ];

        // ルービックキューブの固定された軸方向 (ワールド座標系)
        const worldTopAxis = new THREE.Vector3(0, 1, 0);
        const worldFrontAxis = new THREE.Vector3(0, 0, 1);
        const worldRightAxis = new THREE.Vector3(1, 0, 0);
        const worldLeftAxis = new THREE.Vector3(-1, 0, 0); // Left軸を追加

        const dotTolerance = 0.9; // ドット積の許容誤差 (ベクトルがほぼ平行であることを判定)

        // 指定されたキューブレットの面に対して額縁を作成し追加する関数
// 指定されたキューブレットの面に対して額縁を作成し追加する関数
        function addFaceBorders(cubelet, materialIndex, originalFaceColor) {
//            console.log(`[addFaceBorders] cubelet: ${cubelet.uuid}, materialIndex: ${materialIndex}`);
            const borderMaterial = new THREE.MeshLambertMaterial({ color: originalFaceColor, side: THREE.DoubleSide });

            const halfCubeSize = cubeSize / 2;
            const borderHalfThickness = borderThickness / 2;
            const offsetFromFace = halfCubeSize + borderOffset; // Z-fightingを防ぐためのオフセット

            // Geometry definitions for the strips
            // These are defined as if the face lies on the XY plane with its normal pointing along Z+
            const longStripGeom = new THREE.BoxGeometry(cubeSize, borderThickness, borderThickness);
            const shortStripGeom = new THREE.BoxGeometry(borderThickness, cubeSize - 2 * borderThickness, borderThickness);

            // Calculate the quaternion to orient the strips based on the face's actual orientation
            const faceQuaternion = new THREE.Quaternion();
            const tempObject = new THREE.Object3D(); // Helper object for rotation calculation

            switch (materialIndex) {
                case 0: // Right (+X)
                    tempObject.rotation.y = Math.PI / 2;
                    break;
                case 1: // Left (-X)
                    tempObject.rotation.y = -Math.PI / 2;
                    break;
                case 2: // Top (+Y)
                    tempObject.rotation.x = -Math.PI / 2;
                    break;
                case 3: // Bottom (-Y)
                    tempObject.rotation.x = Math.PI / 2;
                    break;
                case 4: // Front (+Z) - No rotation needed from base orientation
                    break;
                case 5: // Back (-Z)
                    tempObject.rotation.y = Math.PI;
                    break;
            }
            faceQuaternion.copy(tempObject.quaternion);

            // Define the local positions of the strips *as if the face were aligned with the XY plane and its normal was Z+*.
            // These positions are relative to the cubelet's center for a Z+ face.
            const stripConfigs = [
                // Top strip
                { geom: longStripGeom, localPos: new THREE.Vector3(0, halfCubeSize - borderHalfThickness, offsetFromFace) },
                // Bottom strip
                { geom: longStripGeom, localPos: new THREE.Vector3(0, -(halfCubeSize - borderHalfThickness), offsetFromFace) },
                // Left strip
                { geom: shortStripGeom, localPos: new THREE.Vector3(-(halfCubeSize - borderHalfThickness), 0, offsetFromFace) },
                // Right strip
                { geom: shortStripGeom, localPos: new THREE.Vector3(halfCubeSize - borderHalfThickness, 0, offsetFromFace) }
            ];

            stripConfigs.forEach(config => {
                const strip = new THREE.Mesh(config.geom, borderMaterial);

                // 1. ストリップのローカル位置を先に設定
                strip.position.copy(config.localPos);
                // 2. そのローカル位置に、面の向きのクォータニオンを適用して回転させる
                strip.position.applyQuaternion(faceQuaternion);

                // 3. ストリップ自体の向きに、面の向きのクォータニオンを適用する
                strip.quaternion.copy(faceQuaternion);

                strip.userData.isBorderRect = true;
                strip.userData.materialIndex = materialIndex;
                strip.renderOrder = 1; // 枠線をキューブレットの手前に描画
                cubelet.add(strip);
            });
        }

        // 指定されたキューブレットから枠線を削除する関数
        function removeFaceBorders(cubelet) {
//            console.log(`[removeFaceBorders] cubelet: ${cubelet.uuid}`);
            // 一時的に子要素の配列をコピーして、ループ中に要素を削除できるようにする
            const childrenToRemove = cubelet.children.filter(child => child.userData.isBorderRect);

            childrenToRemove.forEach(child => {
                cubelet.remove(child);
                // メモリリークを防ぐためにジオメトリとマテリアルを解放
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose(); // ★修正点: 単一マテリアルの場合もdisposeを呼ぶ
                    }
                }
            });
        }

        function toggleFaceDisplayMode() {
//            console.log(`[toggleFaceDisplayMode] 開始: currentDisplayMode=${currentDisplayMode}, displayModeBeforeAnimation=${displayModeBeforeAnimation}`);
            // アニメーション中は透過モードの切り替えを無効化
            if (isRotating || isCameraAnimating || isShuffling || isUndoing) {
                console.log("[toggleFaceDisplayMode] アニメーション中は透過モードの切り替えはできません。");
                return;
            }

            currentDisplayMode = (currentDisplayMode === 'opaque') ? 'transparent' : 'opaque';
            // ★修正点: 直接透過モードを切り替える場合は、displayModeBeforeAnimationも更新
            displayModeBeforeAnimation = currentDisplayMode; // ここで現在の表示モードを永続化
            applyFaceDisplayMode();
//            console.log(`[toggleFaceDisplayMode] 完了: currentDisplayMode=${currentDisplayMode}, displayModeBeforeAnimation=${displayModeBeforeAnimation}`);
        }

        function applyFaceDisplayMode() {
//            console.log(`[applyFaceDisplayMode] 開始: currentDisplayMode=${currentDisplayMode}, displayModeBeforeAnimation=${displayModeBeforeAnimation}, isRotating=${isRotating}, isCameraAnimating=${isCameraAnimating}, isShuffling=${isShuffling}, isUndoing=${isUndoing}`);
            cubelets.forEach(cubelet => {
                // まず、既存の枠線を全て削除
                removeFaceBorders(cubelet);

                cubelet.updateMatrixWorld(); // ワールド行列を更新

                const materialsToProcess = Array.isArray(cubelet.material) ? cubelet.material : [cubelet.material];

                materialsToProcess.forEach((mat, materialIndex) => {
                    // 最初にマテリアルにオリジナルカラーを保存 (透明度が設定される前に)
                    if (mat.originalColorHex === undefined) {
                        mat.originalColorHex = mat.color.getHex();
                    }

                    const isInnerFaceOriginal = (mat.originalColorHex === colors.black); // オリジナルカラーで内側の面か判定

                    if (currentDisplayMode === 'transparent') { // 透過モード
//                        console.log(`[applyFaceDisplayMode] Cubelet ${cubelet.uuid}, Material ${materialIndex}: Applying transparent mode logic.`);
                        if (isInnerFaceOriginal) {
                            // 内側の面は常に非表示
                            mat.transparent = true;
                            mat.opacity = 0.0;
                            mat.depthWrite = false; // 透明なオブジェクトは深度バッファに書き込まない
//                            console.log(`[applyFaceDisplayMode]   Inner face: Hidden.`);
                        } else {
                            // 外側の面の場合
                            const worldNormal = localFaceNormals[materialIndex].clone().applyQuaternion(cubelet.quaternion);

                            // 面が「Top」「Front」「Right」(TFR) または「Top」「Front」「Left」(TFL) のいずれかであるかを判定
                            let isFramedFace = false; // 枠線表示の対象面

                            const worldPosition = new THREE.Vector3();
                            cubelet.getWorldPosition(worldPosition);
                            const gridX = Math.round(worldPosition.x / gridUnit);
                            const gridY = Math.round(worldPosition.y / gridUnit);
                            const gridZ = Math.round(worldPosition.z / gridUnit);

                            const normalizedWorldNormal = worldNormal.clone().normalize(); // 正規化してドット積を正確にする

                            // デバッグログ追加: 面の向きと判定値
//                            console.log(`[applyFaceDisplayMode]   Cubelet (${gridX},${gridY},${gridZ}) - Face ${materialIndex} (Local Normal: ${localFaceNormals[materialIndex].x},${localFaceNormals[materialIndex].y},${localFaceNormals[materialIndex].z}), World Normal: (${normalizedWorldNormal.x.toFixed(2)}, ${normalizedWorldNormal.y.toFixed(2)}, ${normalizedWorldNormal.z.toFixed(2)})`);

                            if (currentView === 'TFR') {
                                // TFRモード: Top (+Y), Front (+Z), Right (+X) のいずれかの外側の面
                                const dotTop = normalizedWorldNormal.dot(worldTopAxis);
                                const dotFront = normalizedWorldNormal.dot(worldFrontAxis);
                                const dotRight = normalizedWorldNormal.dot(worldRightAxis);

//                                console.log(`[applyFaceDisplayMode]     TFR Mode: Dot Top=${dotTop.toFixed(2)}, Dot Front=${dotFront.toFixed(2)}, Dot Right=${dotRight.toFixed(2)}`);

                                if (Math.abs(gridY) === 1 && dotTop > dotTolerance && gridY === 1) { // Top面 (+Y)
                                    isFramedFace = true;
//                                    console.log(`[applyFaceDisplayMode]       Matched Top Face (Y=1)`);
                                } else if (Math.abs(gridZ) === 1 && dotFront > dotTolerance && gridZ === 1) { // Front面 (+Z)
                                    isFramedFace = true;
//                                    console.log(`[applyFaceDisplayMode]       Matched Front Face (Z=1)`);
                                } else if (Math.abs(gridX) === 1 && dotRight > dotTolerance && gridX === 1) { // Right面 (+X)
                                    isFramedFace = true;
//                                    console.log(`[applyFaceDisplayMode]       Matched Right Face (X=1)`);
                                }
                            } else { // currentView === 'TFL'
                                // TFLモード: Top (+Y), Front (+Z), Left (-X) のいずれかの外側の面
                                const dotTop = normalizedWorldNormal.dot(worldTopAxis);
                                const dotFront = normalizedWorldNormal.dot(worldFrontAxis);
                                const dotLeft = normalizedWorldNormal.dot(worldLeftAxis); // Left軸とのドット積

//                                console.log(`[applyFaceDisplayMode]     TFL Mode: Dot Top=${dotTop.toFixed(2)}, Dot Front=${dotFront.toFixed(2)}, Dot Left=${dotLeft.toFixed(2)}`);

                                if (Math.abs(gridY) === 1 && dotTop > dotTolerance && gridY === 1) { // Top面 (+Y)
                                    isFramedFace = true;
//                                    console.log(`[applyFaceDisplayMode]       Matched Top Face (Y=1)`);
                                } else if (Math.abs(gridZ) === 1 && dotFront > dotTolerance && gridZ === 1) { // Front面 (+Z)
                                    isFramedFace = true;
//                                    console.log(`[applyFaceDisplayMode]       Matched Front Face (Z=1)`);
                                } else if (Math.abs(gridX) === 1 && dotLeft > dotTolerance && gridX === -1) { // Left面 (-X)
                                    isFramedFace = true;
//                                    console.log(`[applyFaceDisplayMode]       Matched Left Face (X=-1)`);
                                }
                            }
//                            console.log(`[applyFaceDisplayMode]   Outer face at (${gridX},${gridY},${gridZ}), isFramedFace=${isFramedFace}`);


                            if (isFramedFace) {
                                // 対象の面は完全に透明にし、額縁を追加 (元の色で)
                                mat.transparent = true;
                                mat.opacity = 0.0;
                                mat.depthWrite = false; // 描画しないので深度書き込みも不要
                                addFaceBorders(cubelet, materialIndex, mat.originalColorHex); // 額縁を追加
//                                console.log(`[applyFaceDisplayMode]     Framed: transparent, borders added.`);
                            } else {
                                // それ以外の外側の面 (Bottom, Left/Right, Backなど) は不透明にする
                                mat.transparent = false; // ここをfalseに
                                mat.opacity = 1.0; // ここを1.0に
                                mat.depthWrite = true; // ここをtrueに
//                                console.log(`[applyFaceDisplayMode]     Not framed: opaque.`);
                            }
                        }
                    } else { // 不透明モード ('opaque')
//                        console.log(`[applyFaceDisplayMode] Cubelet ${cubelet.uuid}, Material ${materialIndex}: Applying opaque mode logic.`);
                        mat.transparent = false;
                        mat.opacity = 1.0;
                        mat.depthWrite = true;
//                        console.log(`[applyFaceDisplayMode]   Opaque.`);
                    }
                    mat.needsUpdate = true;
                });
            });
//            console.log(`[applyFaceDisplayMode] 完了: currentDisplayMode=${currentDisplayMode}`);
        }

        // 初期状態でディスプレイモードを適用 (デフォルトは不透明)
        applyFaceDisplayMode();


        // --- キー入力処理 ---
        let firstKey = null; // 1回目のキー入力
        let lastKeyPressTime = 0; // 最後のキー入力時刻
        const KEY_TIMEOUT = 500; // 2ストローク入力のタイムアウト時間 (ms)

        window.addEventListener('keydown', (event) => {
//            console.log(`[keydown] Event: ${event.key}, firstKey: ${firstKey}, time: ${Date.now()}`);
            const currentTime = Date.now();
            const key = event.key;

            // テンキーの数字（0-9）であるかチェック
            if (key >= '0' && key <= '9') {
                if (firstKey === null || (currentTime - lastKeyPressTime > KEY_TIMEOUT)) {
                    // 1回目の入力、またはタイムアウト後の新たな入力として記録
                    firstKey = key;
//                    console.log(`[keydown] First key set: ${firstKey}`);
                } else {
                    // 2回目の入力。2ストローク操作を実行
                    const operation = firstKey + '-' + key;
//                    console.log("[keydown] Operation (Key):", operation);

                    if (operation === '0-2') { // キューブ状態出力
                        logCubeState();
                    } else if (operation === '0-1') { // シャッフル機能
                        shuffleCube();
                    } else if (operation === '0-0') { // アンドゥ機能
                        undoLastMove();
                    } else if (operation === '5-5') { // カメラ視点変更
                        changeCameraView();
                    } else if (operation === '0-3') { // 透明度トグル
                        toggleFaceDisplayMode();
                    }
                    else {
//                        console.log(`[keydown] Performing rotation: ${operation}. Initial modes: current=${currentDisplayMode}, before=${displayModeBeforeAnimation}`);
                        // ★修正点: 単一のユーザー回転の場合、アニメーション開始前に現在の表示モードを保存
                        displayModeBeforeAnimation = currentDisplayMode;
                        // アニメーションのために一時的に不透明にする（元々透過モードの場合）
                        if (currentDisplayMode === 'transparent') {
//                            console.log("[keydown] Switching to opaque for animation.");
                            currentDisplayMode = 'opaque';
                            applyFaceDisplayMode();
                        }
                        // ルービックキューブの回転操作を実行
                        performRotation(operation);
                    }
                    firstKey = null; // 2ストローク完了後、キー入力をリセット
                }
                lastKeyPressTime = currentTime; // 最終入力時刻を更新
            } else {
                // テンキー以外のキーが押されたら、2ストローク入力状態をリセット
                firstKey = null;
//                console.log("[keydown] Non-numpad key, firstKey reset.");
            }
        });

        // --- タッチ操作処理 ---
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let touchStartX = 0;
        let touchStartY = 0;
        let startNumpad = null;
        let lastTapTime = 0;
        let lastTapNumpad = null;
        const SWIPE_THRESHOLD = 30; // スワイプと認識する最低距離（ピクセル）を緩和
        const DOUBLE_TAP_TIMEOUT = 400; // ダブルタップと認識する時間（ms）を拡大

        // 画面座標からThree.jsのRaycaster用の正規化デバイス座標を取得
        function getNormalizedDeviceCoords(clientX, clientY) {
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            return pointer;
        }

        // Raycastを実行し、交差したキューブレットを返す
        function getIntersectedCubelet(clientX, clientY) {
            const normalizedCoords = getNormalizedDeviceCoords(clientX, clientY);
            raycaster.setFromCamera(normalizedCoords, camera);
            const intersects = raycaster.intersectObjects(cubelets);
            if (intersects.length > 0) {
                return intersects[0].object; // 最も手前のキューブレットを返す
            }
            return null;
        }

        // キューブレットの論理的なグリッド位置 (X, Y, Z) を取得
        function getCubeletGridPosition(cubelet) {
            cubelet.updateMatrixWorld(); // 最新のワールド行列を計算
            const worldPosition = new THREE.Vector3();
            cubelet.getWorldPosition(worldPosition); // キューブレットのワールド座標を取得

            // ワールド座標をルービックキューブの論理的なグリッド座標 (-1, 0, 1) に変換
            const currentGridX = Math.round(worldPosition.x / gridUnit);
            const currentGridY = Math.round(worldPosition.y / gridUnit);
            const currentGridZ = Math.round(worldPosition.z / gridUnit);
            return { x: currentGridX, y: currentGridY, z: currentGridZ };
        }

        // 論理的なグリッド位置からテンキーの数字 (1-9) を取得 (フロント面 Z=1 の場合のみ)
        function getLogicalNumpadPosition(cubelet) {
            const gridPos = getCubeletGridPosition(cubelet);

            // フロント面 (Z=1レイヤー) のキューブレットのみを対象とする
            if (gridPos.z === 1) { // Z=1 のレイヤーが論理的なFront面
                // X: -1(左), 0(中央), 1(右)
                // Y: -1(下), 0(中央), 1(上)
                if (gridPos.y === 1 && gridPos.x === -1) return 7; // Top-Left
                if (gridPos.y === 1 && gridPos.x === 0) return 8;  // Top-Middle
                if (gridPos.y === 1 && gridPos.x === 1) return 9;  // Top-Right
                if (gridPos.y === 0 && gridPos.x === -1) return 4; // Middle-Left
                if (gridPos.y === 0 && gridPos.x === 0) return 5;  // Middle-Center
                if (gridPos.y === 0 && gridPos.x === 1) return 6;  // Middle-Right
                if (gridPos.y === -1 && gridPos.x === -1) return 1; // Bottom-Left
                if (gridPos.y === -1 && gridPos.x === 0) return 2;  // Bottom-Middle
                if (gridPos.y === -1 && gridPos.x === 1) return 3;  // Bottom-Right
            }
            return null; // フロント面 (Z=1) でない、または無効な位置
        }


        renderer.domElement.addEventListener('touchstart', (event) => {
            console.log(`[touchstart] Event. Current animation states: isRotating=${isRotating}, isCameraAnimating=${isCameraAnimating}, isShuffling=${isShuffling}, isUndoing=${isUndoing}`);
            if (isRotating || isCameraAnimating || isShuffling || isUndoing) return;
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;

            const touchedCubelet = getIntersectedCubelet(touchStartX, touchStartY);
            startNumpad = touchedCubelet ? getLogicalNumpadPosition(touchedCubelet) : null;

            console.log(`[touchstart] startNumpad=${startNumpad}`); // デバッグログ追加

            event.preventDefault(); // スクロールを防ぐ
        }, { passive: true }); // passive: true を追加

        renderer.domElement.addEventListener('touchend', (event) => {
            console.log(`[touchend] Event. Current animation states: isRotating=${isRotating}, isCameraAnimating=${isCameraAnimating}, isShuffling=${isShuffling}, isUndoing=${isUndoing}`);
            if (isRotating || isCameraAnimating || isShuffling || isUndoing) {
                // アニメーション中はタップもスワイプも受け付けない
                lastTapTime = 0; // タップ状態もリセット
                lastTapNumpad = null;
                console.log("[touchend] Animation in progress, ignoring touch.");
                return;
            }

            const touchEndX = event.changedTouches[0].clientX;
            const touchEndY = event.changedTouches[0].clientY;

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            const isSwipe = Math.abs(dx) > SWIPE_THRESHOLD || Math.abs(dy) > SWIPE_THRESHOLD;

            const currentTouchedCubelet = getIntersectedCubelet(touchEndX, touchEndY);
            const endNumpad = currentTouchedCubelet ? getLogicalNumpadPosition(currentTouchedCubelet) : null;

            console.log(`[touchend] endNumpad=${endNumpad}, isSwipe=${isSwipe}. Initial modes: current=${currentDisplayMode}, before=${displayModeBeforeAnimation}`); // デバッグログ追加

            if (endNumpad === null) {
                // フロント面のキューブレットに触れていない場合、タップ状態をリセットして終了
                lastTapTime = 0;
                lastTapNumpad = null;
                console.log("[touchend] No cubelet touched or not front face. Resetting tap state.");
                return;
            }

            if (isSwipe) {
                // スワイプが検出された場合
                if (startNumpad !== null && startNumpad !== endNumpad) {
                    const operation = `${startNumpad}-${endNumpad}`;
                    console.log("[touchend] Operation (Swipe):", operation);
                    // テンキー操作を実行
                    if (operation === '0-2') { logCubeState(); }
                    else if (operation === '0-1') { shuffleCube(); }
                    else if (operation === '0-0') { undoLastMove(); }
                    else if (operation === '5-5') { changeCameraView(); }
                    else if (operation === '0-3') { toggleFaceDisplayMode(); } // 透明度トグル
                    else {
                        console.log(`[touchend] Performing rotation (swipe): ${operation}`);
                        // ★修正点: 単一のユーザー回転の場合、アニメーション開始前に現在の表示モードを保存
                        displayModeBeforeAnimation = currentDisplayMode;
                        // アニメーションのために一時的に不透明にする（元々透過モードの場合）
                        if (currentDisplayMode === 'transparent') {
                            console.log("[touchend] Switching to opaque for animation (swipe).");
                            currentDisplayMode = 'opaque';
                            applyFaceDisplayMode();
                        }
                        performRotation(operation);
                    }
                }
                // スワイプ後はダブルタップ状態をリセット
                lastTapTime = 0;
                lastTapNumpad = null;

            } else {
                // タップ（動きが少ない）が検出された場合
                const currentTime = Date.now();

                if (currentTime - lastTapTime < DOUBLE_TAP_TIMEOUT && lastTapNumpad === endNumpad) {
                    // 同じエリアでのダブルタップが検出された
                    const operation = `${endNumpad}-${endNumpad}`;
                    console.log("[touchend] Operation (Double Tap):", operation);
                    // テンキー操作を実行
                    if (operation === '0-2') { logCubeState(); }
                    else if (operation === '0-1') { shuffleCube(); }
                    else if (operation === '0-0') { undoLastMove(); }
                    else if (operation === '5-5') { changeCameraView(); }
                    else if (operation === '0-3') { toggleFaceDisplayMode(); } // 透明度トグル
                    else {
                        console.log(`[touchend] Performing rotation (double tap): ${operation}`);
                        // ★修正点: 単一のユーザー回転の場合、アニメーション開始前に現在の表示モードを保存
                        displayModeBeforeAnimation = currentDisplayMode;
                        // アニメーションのために一時的に不透明にする（元々透過モードの場合）
                        if (currentDisplayMode === 'transparent') {
                            console.log("[touchend] Switching to opaque for animation (double tap).");
                            currentDisplayMode = 'opaque';
                            applyFaceDisplayMode();
                        }
                        performRotation(operation);
                    }

                    lastTapTime = 0; // 次のタップシーケンスのためにリセット
                    lastTapNumpad = null;
                } else {
                    // シングルタップとして記録
                    lastTapTime = currentTime;
                    lastTapNumpad = endNumpad;
                    console.log(`[touchend] Single tap recorded: ${endNumpad}`);
                }
            }
            event.preventDefault(); // ブラウザのデフォルトタッチアクション（スクロールなど）を防ぐ
        });

        // --- 回転処理のためのグループと状態変数 ---
        // ★修正点: 上記で宣言済みなので削除
        // let rotatingGroup = new THREE.Group(); // 回転するキューブレットを一時的にまとめるグループ
        // let isRotating = false; // 現在回転中かどうか
        // let rotationAxis = new THREE.Vector3(); // 回転軸
        // let targetRotationAngle = 0; // 目標の回転角度
        // let currentRotationAngle = 0; // 現在のアニメーション回転角度
        // const rotationSpeed = Math.PI / 15; // 1フレームあたりの回転速度 (シャッフルやアンドゥのために少し速くする)

        // --- カメラアニメーションのための変数 ---
        // ★修正点: 上記で宣言済みなので削除
        // let targetCameraPosition = camera.position.clone(); // カメラの目標位置
        // let targetCameraQuaternion = camera.quaternion.clone(); // カメラの目標クォータニオン (向き)
        // let isCameraAnimating = false; // 現在カメラがアニメーション中かどうか
        // const cameraAnimationSpeed = 0.3; // カメラアニメーションの補間速度 (0.0: 遅い - 1.0: 速い)
        // let currentView = 'TFR'; // 現在のカメラビュー ('TFR': Top-Front-Right, 'TFL': Top-Front-Left)

        // --- シャッフルとアンドゥのための履歴管理 ---
        // ★修正点: 上記で宣言済みなので削除
        // const moveHistory = []; // 実行された操作の履歴
        // let shuffleQueue = []; // シャッフル中に実行する操作のキュー
        // let isShuffling = false; // シャッフル中かどうか
        // let isUndoing = false; // アンドゥ中かどうか


        // 指定された操作に基づいてルービックキューブの回転を実行する関数
        // source: 'user', 'shuffle', 'undo' のいずれか。履歴記録の判断に使う
        function performRotation(operation, source = 'user') {
//            console.log(`[performRotation] 開始: operation=${operation}, source=${source}. Current states: isRotating=${isRotating}, isCameraAnimating=${isCameraAnimating}, isShuffling=${isShuffling}, isUndoing=${isUndoing}`);

            // 回転中またはカメラアニメーション中は、新しい操作を受け付けない
            // ただし、シャッフルやアンドゥ操作自体は回転アニメーションを待つ
            if (isRotating || isCameraAnimating) {
                if (source === 'shuffle' || source === 'undo') {
                    // シャッフルやアンドゥ中に呼ばれた場合は、現在の回転が完了するまで待機
//                    console.log("[performRotation] Animation in progress, deferring shuffle/undo step.");
                    return;
                } else {
                    // ユーザーによる通常の操作の場合は、回転中なら無視
//                    console.log("[performRotation] Animation in progress, ignoring user input.");
                    return;
                }
            }
//            console.log(`[performRotation] Executing rotation: ${operation}`);

            let axis = new THREE.Vector3(); // 回転軸
            let angle = 0; // 回転角度
            let selectAll = false; // 全てのキューブレットを回転させるかどうかのフラグ

            switch (operation) {
                // --- 面の回転 (Right, Front, Top, Left, Bottom) ---
                case '9-9': // Right面 90度時計回転
                case '3-9':
                    axis.set(1, 0, 0); angle = -Math.PI / 2; selectCubeletsByPosition(1, null, null);
                    break;
                case '3-3': // Right面 90度反時計回転
                case '9-3':
                    axis.set(1, 0, 0); angle = Math.PI / 2; selectCubeletsByPosition(1, null, null);
                    break;
                case '7-8': // Front面 時計方向に90度回転
                case '8-9':
                case '9-6':
                case '6-3':
                case '3-2':
                case '2-1':
                case '1-4':
                case '4-7':
                    axis.set(0, 0, 1); angle = -Math.PI / 2; selectCubeletsByPosition(null, null, 1);
                    break;
                case '9-8': // Front面 反時計方向に90度回転
                case '8-7':
                case '7-4':
                case '4-1':
                case '1-2':
                case '2-3':
                case '3-6':
                case '6-9':
                    axis.set(0, 0, 1); angle = Math.PI / 2; selectCubeletsByPosition(null, null, 1);
                    break;
                case '7-9': // Top面 90度時計回転
                    axis.set(0, 1, 0); angle = Math.PI / 2; selectCubeletsByPosition(null, 1, null);
                    break;
                case '9-7': // Top面 90度反時計回転
                    axis.set(0, 1, 0); angle = -Math.PI / 2; selectCubeletsByPosition(null, 1, null);
                    break;
                case '7-7': // Left面 90度時計回転
                case '1-7': // (追加) 7-7と同じ操作
                    axis.set(-1, 0, 0); angle = Math.PI / 2; selectCubeletsByPosition(-1, null, null);
                    break;
                case '1-1': // Left面 90度反時計回転
                case '7-1': // (追加) 1-1と同じ操作
                    axis.set(-1, 0, 0); angle = -Math.PI / 2; selectCubeletsByPosition(-1, null, null);
                    break;
                case '1-3': // Bottom面 90度時計回転
                    axis.set(0, -1, 0); angle = -Math.PI / 2; selectCubeletsByPosition(null, -1, null);
                    break;
                case '3-1': // Bottom面 90度反時計回転
                    axis.set(0, -1, 0); angle = Math.PI / 2; selectCubeletsByPosition(null, -1, null);
                    break;

                // --- キューブ全体の回転 (各軸周り) ---
                case '5-2': // キューブ全体 X軸正方向 +90度
                case '8-5':
                    axis.set(1, 0, 0); angle = Math.PI / 2; selectAll = true;
                    break;
                case '5-8': // キューブ全体 X軸正方向 -90度
                case '2-5':
                    axis.set(1, 0, 0); angle = -Math.PI / 2; selectAll = true;
                    break;
                case '5-4': // キューブ全体 Y軸正方向 -90度
                case '6-5':
                    axis.set(0, 1, 0); angle = -Math.PI / 2; selectAll = true;
                    break;
                case '5-6': // キューブ全体 Y軸正方向 +90度
                case '4-5':
                    axis.set(0, 1, 0); angle = Math.PI / 2; selectAll = true;
                    break;
                case '8-6':
                case '6-2':
                case '2-4':
                case '4-8':
                    axis.set(0, 0, 1); angle = -Math.PI / 2; selectAll = true;
                    break;
                case '8-4':
                case '4-2':
                case '2-6':
                case '6-8':
                    axis.set(0, 0, 1); angle = Math.PI / 2; selectAll = true;
                    break;

                // --- 中央列の回転 ---
                case '8-8': // 中央X列 (X=0) を時計回転 (X軸正方向から見て反時計回り)
                case '2-8':
                    axis.set(1, 0, 0); angle = -Math.PI / 2; selectCubeletsByPosition(0, null, null);
                    break;
                case '8-2': // 中央X列 (X=0) を反時計回転 (X軸正方向から見て時計回り)
                case '2-2':
                    axis.set(1, 0, 0); angle = Math.PI / 2; selectCubeletsByPosition(0, null, null);
                    break;
                case '6-6': // 中央Y列 (Y=0) を時計回転 (Y軸正方向から見て時計回り)
                case '4-6':
                    axis.set(0, 1, 0); angle = Math.PI / 2; selectCubeletsByPosition(null, 0, null);
                    break;
                case '4-4': // 中央Y列 (Y=0) を反時計回転 (Y軸正方向から見て反時計回り)
                case '6-4':
                    axis.set(0, 1, 0); angle = -Math.PI / 2; selectCubeletsByPosition(null, 0, null);
                    break;
                case '1-9': // Z=0面を時計回転 (Front面基準) - 変更
                case '7-3': // Z=0面を時計回転 (Front面基準) - 変更
                    axis.set(0, 0, 1); angle = -Math.PI / 2; selectCubeletsByPosition(null, null, 0);
                    break;
                case '9-1': // Z=0面を反時計回転 (Front面基準) - 変更
                case '3-7': // Z=0面を反時計回転 (Front面基準) - 変更
                    axis.set(0, 0, 1); angle = Math.PI / 2; selectCubeletsByPosition(null, null, 0);
                    break;


                default:
                    console.log("[performRotation] 不明な操作:", operation);
                    return; // 処理を中断
            }

            // 履歴への追加は、アンドゥ操作でない場合に行う
            if (source !== 'undo') {
                moveHistory.push(operation);
                console.log("[performRotation] 履歴に追加:", operation);
            }

            // キューブ全体を回転させる場合は、全てのキューブレットを選択
            if (selectAll) {
                selectCubeletsByPosition(null, null, null); // 全てのキューブレットを選択
            }

            // 回転アニメーションの初期設定
            rotationAxis.copy(axis);
            targetRotationAngle = angle;
            currentRotationAngle = 0;
            isRotating = true;
            updateButtonStates(); // ボタンの状態を更新
//            console.log(`[performRotation] 完了. isRotating=${isRotating}`);
        }

        // 指定された軸位置のキューブレットを選択し、回転グループに追加する関数
        function selectCubeletsByPosition(xVal, yVal, zVal) {
//            console.log(`[selectCubeletsByPosition] X=${xVal}, Y=${yVal}, Z=${zVal}`);
            // 回転開始時に、全てのキューブレットから枠線を削除
            cubelets.forEach(cubelet => {
                removeFaceBorders(cubelet);
            });

            rotatingGroup = new THREE.Group(); // 新しい回転グループを初期化

            // 条件に合うキューブレットをフィルタリング
            const selectedCubelets = cubelets.filter(cubelet => {
                cubelet.updateMatrixWorld(); // 最新のワールド行列を計算
                const worldPosition = new THREE.Vector3();
                cubelet.getWorldPosition(worldPosition); // キューブレットのワールド座標を取得

                const tolerance = gridUnit / 2; // 位置比較の許容誤差

                // 各軸の値が指定されている場合は、その軸の位置が条件を満たすかチェック
                const inX = xVal === null || Math.abs(worldPosition.x - xVal * gridUnit) < tolerance;
                const inY = yVal === null || Math.abs(worldPosition.y - yVal * gridUnit) < tolerance;
                const inZ = zVal === null || Math.abs(worldPosition.z - zVal * gridUnit) < tolerance;

                return inX && inY && inZ; // 全ての条件を満たすキューブレットを選択
            });

            // 選択されたキューブレットをシーンから外し、回転グループの子として追加
            selectedCubelets.forEach(cubelet => {
                scene.remove(cubelet);
                rotatingGroup.add(cubelet);
            });
            scene.add(rotatingGroup); // 回転グループをシーンに追加
//            console.log(`[selectCubeletsByPosition] Selected ${selectedCubelets.length} cubelets.`);
        }

        // 回転完了後にキューブレットのワールド位置と回転を更新し、シーンに再配置する関数
        // source: 'user', 'shuffle', 'undo' のいずれか。次の操作の判断に使う
        function updateCubeletPositions(source = 'user') {
//            console.log(`[updateCubeletPositions] 開始: source=${source}. currentDisplayMode=${currentDisplayMode}, displayModeBeforeAnimation=${displayModeBeforeAnimation}, isRotating=${isRotating}, isShuffling=${isShuffling}, isUndoing=${isUndoing}`);

            // 回転グループ内の全ての子キューブレットを処理
            for (let i = rotatingGroup.children.length - 1; i >= 0; i--) {
                const cubelet = rotatingGroup.children[i];

                // グループの回転が適用された後の、キューブレットのワールド座標と回転を取得
                rotatingGroup.updateMatrixWorld(true); // グループのワールド行列を更新
                cubelet.updateMatrixWorld(true);        // キューブレットのワールド行列を更新

                const worldPosition = new THREE.Vector3();
                cubelet.getWorldPosition(worldPosition);
                const worldQuaternion = new THREE.Quaternion();
                cubelet.getWorldQuaternion(worldQuaternion);

                // キューブレット自身の位置と回転をワールド座標/回転で上書き
                // これにより、シーンの直接の子になってもその状態を維持
                cubelet.position.copy(worldPosition);
                cubelet.quaternion.copy(worldQuaternion);
                cubelet.matrix.identity(); // ローカル行列をリセット
                // 新しいローカル行列を位置、回転、スケールから再構成
                cubelet.matrix.compose(cubelet.position, cubelet.quaternion, cubelet.scale);

                // --- 精度誤差対策: 位置と回転の丸め込み ---
                cubelet.position.x = Math.round(cubelet.position.x / gridUnit) * gridUnit;
                cubelet.position.y = Math.round(cubelet.position.y / gridUnit) * gridUnit;
                cubelet.position.z = Math.round(cubelet.position.z / gridUnit) * gridUnit;

                // 回転も90度の倍数に丸める
                const euler = new THREE.Euler().setFromQuaternion(cubelet.quaternion, 'XYZ');
                euler.x = Math.round(euler.x / (Math.PI / 2)) * (Math.PI / 2);
                euler.y = Math.round(euler.y / (Math.PI / 2)) * (Math.PI / 2);
                euler.z = Math.round(euler.z / (Math.PI / 2)) * (Math.PI / 2);
                cubelet.quaternion.setFromEuler(euler);
                // --- 精度誤差対策 終わり ---

                scene.add(cubelet); // シーンに直接追加
            }

            rotatingGroup.clear(); // 回転グループから全ての子を削除 (グループは空になる)

            // cubelets配列を更新し、シーン内の現在のBoxGeometryメッシュを参照するようにする
            cubelets.length = 0; // 配列をクリア
            scene.traverse(object => {
                if (object.isMesh && object.geometry.type === 'BoxGeometry') {
                    cubelets.push(object);
                }
            });

            isRotating = false; // 回転アニメーション終了
            updateButtonStates(); // ボタンの状態を更新

            // ★修正点: シャッフル中やアンドゥ中は個々の回転後に透過モードを復元しない。
            // 透過モードの復元は、シャッフルまたはアンドゥの全シーケンスが完了した時にのみ行う。
            // ここでのapplyFaceDisplayMode()の直接呼び出しは削除し、以下のロジックに集約
            if (!isShuffling && !isUndoing) {
//                console.log("[updateCubeletPositions] Single user move completed. Restoring display mode.");
                currentDisplayMode = displayModeBeforeAnimation;
                applyFaceDisplayMode();
            }


            // シャッフル中であれば次の操作を実行
            if (isShuffling && shuffleQueue.length > 0) {
//                console.log(`[updateCubeletPositions] Shuffle continuing. Remaining: ${shuffleQueue.length}`);
                // 少し遅延を入れて次の回転を開始 (アニメーションが見やすくなるように)
                setTimeout(() => {
                    // ★修正点: 次の回転操作の前に透過モードの一時的な不透明化を再度適用
                    if (displayModeBeforeAnimation === 'transparent') {
//                        console.log("[updateCubeletPositions] Shuffle: Setting to opaque for next step.");
                        currentDisplayMode = 'opaque';
                        applyFaceDisplayMode();
                    }
                    performRotation(shuffleQueue.shift(), 'shuffle');
                }, 100); // 100msの遅延
            } else if (isShuffling && shuffleQueue.length === 0) {
                isShuffling = false;
//                console.log("[updateCubeletPositions] シャッフル完了！Restoring display mode.");
                // ★修正点: シャッフル完了後に透過モードを復元
                currentDisplayMode = displayModeBeforeAnimation;
                applyFaceDisplayMode();
                updateButtonStates(); // シャッフル完了時にも更新
            }

            // アンドゥ中であれば次の操作を実行
            if (isUndoing && shuffleQueue.length > 0) { // シャッフルと同じキューを利用
//                console.log(`[updateCubeletPositions] Undo continuing. Remaining: ${shuffleQueue.length}`);
                setTimeout(() => {
                    // ★修正点: 次の回転操作の前に透過モードの一時的な不透明化を再度適用
                    if (displayModeBeforeAnimation === 'transparent') {
//                        console.log("[updateCubeletPositions] Undo: Setting to opaque for next step.");
                        currentDisplayMode = 'opaque';
                        applyFaceDisplayMode();
                    }
                    performRotation(shuffleQueue.shift(), 'undo'); // アンドゥの逆操作を実行
                }, 100); // 100msの遅延
            } else if (isUndoing && shuffleQueue.length === 0) {
                isUndoing = false;
//                console.log("[updateCubeletPositions] アンドゥ完了！Restoring display mode.");
                // ★修正点: アンドゥ完了後に透過モードを復元
                currentDisplayMode = displayModeBeforeAnimation;
                applyFaceDisplayMode();
                updateButtonStates();
            }
//            console.log(`[updateCubeletPositions] 完了. currentDisplayMode=${currentDisplayMode}`);
        }

        // --- シャッフル機能 ---
        // 全ての可能な回転操作を定義
        const ALL_FACES = [
            '9-9', '3-3', // Right
            '7-8', '9-8', // Front
            '7-9', '9-7', // Top
            '7-7', '1-1', // Left
            '1-3', '3-1', // Bottom
            '5-2', '5-8', // Cube X
            '5-4', '5-6', // Cube Y
            '8-6', '8-4', // Cube Z
            '8-8', '8-2', // Middle X
            '6-6', '4-4', // Middle Y
            '1-9', '9-1'  // Middle Z (Updated)
        ];

        async function shuffleCube() {
            console.log(`[shuffleCube] 開始. currentDisplayMode=${currentDisplayMode}, displayModeBeforeAnimation=${displayModeBeforeAnimation}`);
            // ★修正点: アニメーション開始前に現在の表示モードを保存する
            displayModeBeforeAnimation = currentDisplayMode;

            // アニメーションのために一時的に不透明にする（元々透過モードの場合）
            if (currentDisplayMode === 'transparent') {
                console.log("[shuffleCube] Setting to opaque for shuffle animation.");
                currentDisplayMode = 'opaque';
                applyFaceDisplayMode();
            }

            if (isRotating || isShuffling || isUndoing || isCameraAnimating) {
                console.log("[shuffleCube] Animation in progress, ignoring shuffle request.");
                return; // 回転中やシャッフル中は無視
            }

            console.log("[shuffleCube] シャッフルを開始します...");
            isShuffling = true;
            shuffleQueue = []; // シャッフル操作のキューをクリア

            const numMoves = 20; // シャッフルする手数
            // シャッフル操作は、履歴に「個々の回転」として追加される
            for (let i = 0; i < numMoves; i++) {
                // ランダムな操作を選択
                const randomIndex = Math.floor(Math.random() * ALL_FACES.length);
                shuffleQueue.push(ALL_FACES[randomIndex]);
            }

            // 最初のシャッフル操作を開始
            performRotation(shuffleQueue.shift(), 'shuffle');
            updateButtonStates(); // シャッフル開始時にも更新
            console.log("[shuffleCube] 完了. First rotation initiated.");
        }

        // --- アンドゥ機能 ---
        function undoLastMove() {
            console.log(`[undoLastMove] 開始. currentDisplayMode=${currentDisplayMode}, displayModeBeforeAnimation=${displayModeBeforeAnimation}`);
            // ★修正点: アニメーション開始前に現在の表示モードを保存する
            displayModeBeforeAnimation = currentDisplayMode;

            // アニメーションのために一時的に不透明にする（元々透過モードの場合）
            if (currentDisplayMode === 'transparent') {
                console.log("[undoLastMove] Setting to opaque for undo animation.");
                currentDisplayMode = 'opaque';
                applyFaceDisplayMode();
            }

            if (isRotating || isCameraAnimating || isShuffling || isUndoing) {
                console.log("[undoLastMove] Animation in progress, ignoring undo request.");
                return; // 回転中やシャッフル中は無視
            }

            if (moveHistory.length === 0) {
                console.log("[undoLastMove] アンドゥできる操作がありません。");
                return;
            }

            console.log("[undoLastMove] アンドゥを開始します...");
            isUndoing = true;
            shuffleQueue = []; // アンドゥ操作のキューをクリア（シャッフルと同じキューを利用）

            const lastMove = moveHistory.pop(); // 最後の操作を取り出す
            const reverseMove = getReverseOperation(lastMove); // その操作の逆を取得

            if (reverseMove) {
                shuffleQueue.push(reverseMove); // 逆操作をキューに追加
                performRotation(shuffleQueue.shift(), 'undo'); // 逆操作を実行
                console.log(`[undoLastMove] 直前の操作 "${lastMove}" をアンドゥしました。逆操作: "${reverseMove}"`);
            } else {
                console.log(`[undoLastMove] 逆操作が定義されていません: ${lastMove}`);
                isUndoing = false;
            }
            updateButtonStates(); // アンドゥ開始時にも更新
            console.log("[undoLastMove] 完了. First rotation initiated.");
        }

        // 操作の逆操作を取得するヘルパー関数
        function getReverseOperation(operation) {
            switch (operation) {
                // 面の回転
                case '9-9':
                case '3-9': return '3-3'; // 9-9, 3-9 の逆は 3-3, 9-3
                case '3-3':
                case '9-3': return '9-9'; // 3-3, 9-3 の逆は 9-9, 3-9
                case '7-8':
                case '8-9':
                case '9-6':
                case '6-3':
                case '3-2':
                case '2-1':
                case '1-4':
                case '4-7': return '9-8'; // Front面時計回転の逆はFront面反時計回転
                case '9-8':
                case '8-7':
                case '7-4':
                case '4-1':
                case '1-2':
                case '2-3':
                case '3-6':
                case '6-9': return '7-8'; // Front面反時計回転の逆はFront面時計回転
                case '7-9': return '9-7';
                case '9-7': return '7-9';
                case '7-7':
                case '1-7': return '1-1'; // 7-7, 1-7 の逆は 1-1, 7-1
                case '1-1':
                case '7-1': return '7-7'; // 1-1, 7-1 の逆は 7-7, 1-7
                case '1-3': return '3-1';
                case '3-1': return '1-3';

                // キューブ全体の回転
                case '5-2':
                case '8-5': return '5-8'; // 5-2, 8-5 の逆は 5-8, 2-5
                case '5-8':
                case '2-5': return '5-2'; // 5-8, 2-5 の逆は 5-2, 8-5
                case '5-4':
                case '6-5': return '5-6'; // 5-4, 6-5 の逆は 5-6, 4-5
                case '5-6':
                case '4-5': return '5-4'; // 4-5, 6-5 の逆は 5-4, 6-5
                case '8-6':
                case '6-2':
                case '2-4':
                case '4-8': return '8-4'; // 8-6, 6-2, 2-4, 4-8 の逆は 8-4, 4-2, 2-6, 6-8
                case '8-4':
                case '4-2':
                case '2-6':
                case '6-8': return '8-6'; // 8-4, 4-2, 2-6, 6-8 の逆は 8-6, 6-2, 2-4, 6-8

                // 中央列の回転
                case '8-8':
                case '2-8': return '8-2'; // 8-8, 2-8 の逆は 8-2, 2-2
                case '8-2':
                case '2-2': return '8-8'; // 8-2, 2-2 の逆は 8-8, 2-8
                case '6-6':
                case '4-6': return '4-4'; // 6-6, 4-6 の逆は 4-4, 6-4
                case '4-4':
                case '6-4': return '6-6'; // 4-4, 6-4 の逆は 6-6, 4-6
                case '1-9':
                case '3-7': return '9-1'; // Updated Z-axis middle layer operations
                case '9-1':
                case '7-3': return '1-9'; // Updated Z-axis middle layer operations
                default: return null;
            }
        }

        // --- アニメーションループ ---
        function animate() {
            requestAnimationFrame(animate); // 次のフレームで再度この関数を呼び出す

            // デバッグログ追加: 現在のアニメーション状態を表示
            // console.log(`[animate] Loop: isRotating=${isRotating}, isCameraAnimating=${isCameraAnimating}, isShuffling=${isShuffling}, isUndoing=${isUndoing}`);

            if (isRotating) {
                let angleStep = rotationSpeed;
                // 目標角度に近づいたら残りの角度に調整し、回転を終了
                if (Math.abs(targetRotationAngle - currentRotationAngle) < angleStep) {
                    angleStep = Math.abs(targetRotationAngle - currentRotationAngle);
                    isRotating = false; // 回転アニメーションの完了をマーク
//                    console.log("[animate] Rotation animation completed. Calling updateCubeletPositions.");
                }
                // 回転クォータニオンを作成し、回転グループに適用
                const rotateQuaternion = new THREE.Quaternion();
                rotateQuaternion.setFromAxisAngle(rotationAxis, targetRotationAngle > currentRotationAngle ? angleStep : -angleStep);
                rotatingGroup.applyQuaternion(rotateQuaternion);
                currentRotationAngle += (targetRotationAngle > currentRotationAngle ? angleStep : -angleStep);

                if (!isRotating) { // 回転が完了したフレームで一度だけ呼び出す
                    // isShuffling と isUndoing の状態に基づいて source を決定
                    const source = isShuffling ? 'shuffle' : (isUndoing ? 'undo' : 'user');
                    updateCubeletPositions(source);
                }
            }

            // --- カメラのアニメーション ---
            if (isCameraAnimating) {
                // カメラの位置と向きを目標値へ向かって滑らかに補間
                camera.position.lerp(targetCameraPosition, cameraAnimationSpeed);
                camera.quaternion.slerp(targetCameraQuaternion, cameraAnimationSpeed);

                // カメラが目標位置と目標向きに十分近づいたらアニメーションを終了
                if (camera.position.distanceTo(targetCameraPosition) < 0.1 &&
                    camera.quaternion.angleTo(targetCameraQuaternion) < 0.001) {
                    camera.position.copy(targetCameraPosition); // 完全に目標位置に設定
                    camera.quaternion.copy(targetCameraQuaternion); // 完全に目標向きに設定
                    isCameraAnimating = false;
//                    console.log("[animate] カメラアニメーション完了。Restoring display mode.");
                    updateButtonStates(); // カメラアニメーション完了時にも更新
                    // ★修正点: アニメーション後に透過モードを復元
                    currentDisplayMode = displayModeBeforeAnimation;
                    applyFaceDisplayMode();
                }
            }

            renderer.render(scene, camera); // シーンをカメラを通して描画
        }

        // ウィンドウのリサイズイベントに対応
        window.addEventListener('resize', () => {
            console.log("[resize] Window resized.");
            const width = window.innerWidth;
            const height = window.innerHeight;

            // 透視投影カメラの視野を更新
            camera.aspect = width / height; // アスペクト比を更新
            camera.updateProjectionMatrix(); // 投影行列を更新

            renderer.setSize(width, height); // レンダラーのサイズも更新
            applyFaceDisplayMode(); // リサイズ後にも描画モードを再適用
        });

        animate(); // アニメーションループを開始

        // --- カメラビュー変更関数 ---
        function changeCameraView() {
//            console.log(`[changeCameraView] 開始. currentDisplayMode=${currentDisplayMode}, displayModeBeforeAnimation=${displayModeBeforeAnimation}`);
            // ★修正点: アニメーション開始前に現在の表示モードを保存する
            displayModeBeforeAnimation = currentDisplayMode;

            // アニメーションのために一時的に不透明にする（元々透過モードの場合）
            if (currentDisplayMode === 'transparent') {
//                console.log("[changeCameraView] Setting to opaque for camera animation.");
                currentDisplayMode = 'opaque';
                applyFaceDisplayMode();
            }

            if (isCameraAnimating || isRotating || isShuffling || isUndoing) {
//                console.log("[changeCameraView] Animation in progress, ignoring camera view change request.");
                return; // アニメーション中は新しい操作を受け付けない
            }

            let newPosition = new THREE.Vector3();
            let newLookAt = new THREE.Vector3(0, 0, 0); // 常に原点を見る

            if (currentView === 'TFR') {
                // 現在のビューがTop-Front-Rightなら、Top-Front-Leftへ切り替え
                newPosition.set(-200, 200, 600); // 左上奥からの視点 (調整済み)
//                console.log("[changeCameraView] カメラビューをTop-Front-Leftに変更します。");
                currentView = 'TFL';
            } else {
                // 現在のビューがTop-Front-Leftなら、Top-Front-Rightへ切り替え
                newPosition.set(200, 200, 600); // 右上奥からの視点 (初期値、調整済み)
//                console.log("[changeCameraView] カメラビューをTop-Front-Rightに変更します。");
                currentView = 'TFR';
            }

            // 目標位置と目標クォータニオンを設定し、アニメーションを開始
            targetCameraPosition.copy(newPosition);
            const tempCameraForTarget = new THREE.PerspectiveCamera(); // 一時的なカメラで目標の向きを計算
            tempCameraForTarget.position.copy(newPosition);
            tempCameraForTarget.lookAt(newLookAt);
            targetCameraQuaternion.copy(tempCameraForTarget.quaternion);

            isCameraAnimating = true; // カメラアニメーションを開始
            updateButtonStates(); // カメラアニメーション開始時にも更新
//            console.log("[changeCameraView] 完了. Camera animation started.");
        }


        // --- デバッグ用の関数: キューブの現在の状態をコンソールに出力 ---
        function logCubeState() {
            console.log("\n--- Rubik's Cube State ---");

            // 各面の色の状態を保持する配列を初期化（全て空白で埋める）
            const faceStates = {
                'Top': Array(9).fill(' '),    // White (Y+面)
                'Bottom': Array(9).fill(' '), // Yellow (Y-面)
                'Front': Array(9).fill(' '),  // Blue (Z+面)
                'Back': Array(9).fill(' '),    // Green (Z-面)
                'Left': Array(9).fill(' '),    // Red (X-面)
                'Right': Array(9).fill(' ')    // Orange (X+面)
            };

            // ワールド座標系における各面の基準方向ベクトル
            const worldAxes = {
                'Top': new THREE.Vector3(0, 1, 0),
                'Bottom': new THREE.Vector3(0, -1, 0),
                'Front': new THREE.Vector3(0, 0, 1),
                'Back': new THREE.Vector3(0, 0, -1),
                'Left': new THREE.Vector3(-1, 0, 0),
                'Right': new THREE.Vector3(1, 0, 0)
            };

            const tolerance = 0.01; // 位置やベクトルの比較における許容誤差

            // 各キューブレットをループし、それぞれの面の状態を収集
            cubelets.forEach(cubelet => {
                cubelet.updateMatrixWorld(); // キューブレットのワールド行列を常に最新に更新

                const worldPosition = new THREE.Vector3();
                cubelet.getWorldPosition(worldPosition); // ワールド座標を取得

                // ワールド座標をルービックキューブの論理的なグリッド座標 (-1, 0, 1) に変換
                const currentGridX = Math.round(worldPosition.x / gridUnit);
                const currentGridY = Math.round(worldPosition.y / gridUnit);
                const currentGridZ = Math.round(worldPosition.z / gridUnit);

                // 各キューブレットの6面それぞれについて、その面のワールド向きと色をチェック
                // BoxGeometryの面の順序: Right (+X), Left (-X), Top (+Y), Bottom (-Y), Front (+Z), Back (-Z)
                const localFaceNormals = [
                    new THREE.Vector3(1, 0, 0),    // 0: Right (+X)
                    new THREE.Vector3(-1, 0, 0),   // 1: Left (-X)
                    new THREE.Vector3(0, 1, 0),    // 2: Top (+Y)
                    new THREE.Vector3(0, -1, 0),   // 3: Bottom (-Y)
                    new THREE.Vector3(0, 0, 1),    // 4: Front (+Z)
                    new THREE.Vector3(0, 0, -1)    // 5: Back (-Z)
                ];

                // cubelet.materialが単一のマテリアルか、配列であるかに対応
                const materialsToProcess = Array.isArray(cubelet.material) ? cubelet.material : [cubelet.material];

                materialsToProcess.forEach((mat, materialIndex) => {
                    const worldNormal = localFaceNormals[materialIndex].clone();
                    worldNormal.applyQuaternion(cubelet.quaternion); // ローカル法線にキューブレットの回転を適用し、ワールド法線に変換

                    // オリジナルカラーがまだ保存されていなければ保存
                    const originalColorCode = mat.originalColorHex !== undefined ? mat.originalColorHex : mat.color.getHex();
                    const colorAlias = colorAliases[originalColorCode] || '?'; // 定義された色の略称、または不明な場合は'?'

                    let row, col;

                    // 各面ごとのマッピングロジック (現在のグリッド座標とワールド法線から、どの面のどの位置かを判定)
                    // Top面 (White): Y+方向を向いているキューブレットの上面
                    if (currentGridY === 1 && worldNormal.dot(worldAxes.Top) > 1 - tolerance) {
                        row = 1 - currentGridZ; // Z座標を0,1,2にマッピング（手前が上）
                        col = currentGridX + 1; // X座標を0,1,2にマッピング（左が左）
                        faceStates.Top[row * 3 + col] = colorAlias;
                    }
                    // Bottom面 (Yellow): Y-方向を向いているキューブレットの下面
                    else if (currentGridY === -1 && worldNormal.dot(worldAxes.Bottom) > 1 - tolerance) {
                        row = currentGridZ + 1; // Z座標を0,1,2にマッピング（奥が上）
                        col = currentGridX + 1; // X座標を0,1,2にマッピング（左が左）
                        faceStates.Bottom[row * 3 + col] = colorAlias;
                    }
                    // Front面 (Blue): Z+方向を向いているキューブレットの前面
                    else if (currentGridZ === 1 && worldNormal.dot(worldAxes.Front) > 1 - tolerance) {
                        row = 1 - currentGridY; // Y座標を0,1,2にマッピング（上が上）
                        col = currentGridX + 1; // X座標を0,1,2にマッピング（左が左）
                        faceStates.Front[row * 3 + col] = colorAlias;
                    }
                    // Back面 (Green): Z-方向を向いているキューブレットの背面
                    else if (currentGridZ === -1 && worldNormal.dot(worldAxes.Back) > 1 - tolerance) {
                        row = 1 - currentGridY; // Y座標を0,1,2にマッピング（上が上）
                        col = 1 - currentGridX; // X座標を0,1,2にマッピング（右が左）
                        faceStates.Back[row * 3 + col] = colorAlias;
                    }
                    // Left面 (Red): X-方向を向いているキューブレットの左面
                    else if (currentGridX === -1 && worldNormal.dot(worldAxes.Left) > 1 - tolerance) {
                        row = 1 - currentGridY; // Y座標を0,1,2にマッピング（上が上）
                        col = currentGridZ + 1; // Z座標を0,1,2にマッピング（奥が左）
                        faceStates.Left[row * 3 + col] = colorAlias;
                    }
                    // Right面 (Orange): X+方向を向いているキューブレットの右面
                    else if (currentGridX === 1 && worldNormal.dot(worldAxes.Right) > 1 - tolerance) {
                        row = 1 - currentGridY; // Y座標を0,1,2にマッピング（上が上）
                        col = 1 - currentGridZ; // Z座標を0,1,2にマッピング（手前が左）
                        faceStates.Right[row * 3 + col] = colorAlias;
                    }
                });
            });

            // コンソール出力の整形関数
            const printFace = (name, colorsArr) => {
                console.log(`--- ${name} ---`);
                console.log(`${colorsArr[0]}${colorsArr[1]}${colorsArr[2]}`);
                console.log(`${colorsArr[3]}${colorsArr[4]}${colorsArr[5]}`);
                console.log(`${colorsArr[6]}${colorsArr[7]}${colorsArr[8]}`);
            };

            // ルービックキューブの標準的な配置順で各面を出力
            printFace('Top (White)', faceStates.Top);
            printFace('Left (Red)', faceStates.Left);
            printFace('Front (Blue)', faceStates.Front);
            printFace('Right (Orange)', faceStates.Right);
            printFace('Back (Green)', faceStates.Back);
            printFace('Bottom (Yellow)', faceStates.Bottom);

            console.log("----------------------");
        }

        // --- ボタン要素の取得とイベントリスナーの設定 ---
        const shuffleButton = document.getElementById('shuffleButton');
        const undoButton = document.getElementById('undoButton');
        const cameraViewButton = document.getElementById('cameraViewButton');
        const toggleTransparencyButton = document.getElementById('toggleTransparencyButton'); // 新しいボタン

        if (shuffleButton) {
            shuffleButton.addEventListener('click', shuffleCube);
        }
        if (undoButton) {
            undoButton.addEventListener('click', undoLastMove);
        }
        if (cameraViewButton) {
            cameraViewButton.addEventListener('click', changeCameraView);
        }
        if (toggleTransparencyButton) { // 新しいボタンのイベントリスナーを設定
            toggleTransparencyButton.addEventListener('click', toggleFaceDisplayMode);
        }

        // ボタンの活性/非活性を制御する関数
        function updateButtonStates() {
            const isAnyAnimationInProgress = isRotating || isCameraAnimating || isShuffling || isUndoing;
//            console.log(`[updateButtonStates] isAnyAnimationInProgress=${isAnyAnimationInProgress}, history_length=${moveHistory.length}`);

            if (shuffleButton) { // 存在を確認
                shuffleButton.disabled = isAnyAnimationInProgress;
            }
            if (undoButton) { // 存在を確認
                undoButton.disabled = isAnyAnimationInProgress || moveHistory.length === 0;
            }
            if (cameraViewButton) { // 存在を確認
                cameraViewButton.disabled = isAnyAnimationInProgress;
            }
            if (toggleTransparencyButton) { // 存在を確認
                toggleTransparencyButton.disabled = isAnyAnimationInProgress;
            }
        }

        // 初期ロード時にボタンの状態を更新
        updateButtonStates();
    </script>
</body>
</html>
